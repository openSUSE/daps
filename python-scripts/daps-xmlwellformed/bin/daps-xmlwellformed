#!/usr/bin/env python3
#
# This script is needed as xmllint cannot ignore double IDs
# lxml
#
#
"""Performs a well-formedness check on XML.

 * Does XInclude processing before any checks;
 * Warns about files which cannot be found
 * Ignores non-unique IDs (attributes xml:id or id)
"""

__author__ = "Thomas Schraitle"
__version__ = "0.2.1"

import argparse
import enum
import os
import re
import sys
import textwrap
import warnings

from lxml import etree


__file__ = os.path.realpath(__file__)
HERE = os.path.dirname(__file__)
BASE = os.path.basename(__file__)
XINCLUDE_XSLT = os.path.join(HERE, "%s-xinclude.xsl" % BASE)
SUSE_NS = "urn:x-suse:ns:python"
ENTITY_NOT_FOUND = re.compile(
    r"FATAL:PARSER:ERR_UNDECLARED_ENTITY:\s"
    r"[Ee]ntity\s+'([\w_-]+)'\s+not defined"
)


if etree.LXML_VERSION < (3, 4, 0):
    print("ERROR: I need a minimum version of 3.4.0 of lxml.",
          file=sys.stderr)
    sys.exit(10)

if not os.path.exists(XINCLUDE_XSLT):
    print("ERROR: Missing file %s" % XINCLUDE_XSLT, file=sys.stderr)
    sys.exit(125)


class ExitCode(enum.IntEnum):
    """
    """
    ok, syntax, entities, xinclude, file_not_found = range(0, 50, 10)
    unknown = 100


def is_entity_error(msg: str) -> bool:
    """
    Checks for undefined entity
    """
    return bool(ENTITY_NOT_FOUND.search(msg))


def is_syntax_error(msg: str) -> bool:
    """
    Checks for common XML syntax errors
    """
    possible_errors = (
        "FATAL:PARSER:ERR_NAME_REQUIRED",
        # "FATAL:PARSER:ERR_UNDECLARED_ENTITY",
        "FATAL:PARSER:ERR_NAME_REQUIRED",
        "FATAL:PARSER:ERR_TAG_NAME_MISMATCH",
    )
    return any(errormsg in msg for errormsg in possible_errors)

# ------------------------------------------------------------
# Extension Functions in a SUSE namespace

def exists(context, f) -> bool:
    """Test whether a path exists.  Returns False for
       broken symbolic links

        :param context:
        :param list f: list of path name (however, we
                       are only interested in the first
                       item
        :return: True=Path exists, False otherwise
        :rtype: bool
    """
    f = f[0]
    d = context.context_node.getroottree().docinfo.URL
    d = os.path.dirname(d)
    return os.path.exists(os.path.join(d, f))


def abspath(context, f) -> str:
    """Return the absolute path of the context node

        :param context:
        :param list f: list of path name (however, we
                       are only interested in the first
                       item
        :return: absolute path
        :rtype: str
    """
    f = f[0]
    d = context.context_node.getroottree().docinfo.URL
    d = os.path.dirname(d)
    return os.path.abspath(os.path.join(d, f))


# ------------------------------------------------------------
#

def process_xinclude(tree) -> list:
    """Process the tree with a XSLT stylesheet which
       resolves any XIncludes. Prints

    :param tree: the ElementTree
    """
    # This notation is needed for lxml <v4:
    ns = etree.FunctionNamespace(SUSE_NS)
    ns['exists'] = exists
    ns['abspath'] = abspath

    # tree.xinclude()
    # HACK for lxml < v4.2.1:
    # This test is needed to perform XInclude resolution on
    # second and third levels:
    # if list(tree.iter("{http://www.w3.org/2001/XInclude}include")):
    #    tree.xinclude()

    # Let's use XSLT to handle XIncludes manually; this is needed
    # for two reasons:
    # 1. lxml seems to have a bug when resolving XIncludes on the
    #    second level
    # 2. we need to handle cases where the file cannot be found
    xitransform = etree.XSLT(etree.parse(XINCLUDE_XSLT))
    # problems = []
    try:
        xitransform(tree)
        for entry in xitransform.error_log:
            yield entry

    except etree.XSLTApplyError as err:
        # We search for "Cannot resolve URI <FILENAME>"
        uri = err.args[0].split("URI ")[-1]
        # problems.append(uri)
        yield err

    # yield


def process_transform_output(entries) -> int:
    """
    """
    all_warnings = []
    for entry in entries:
        msg = entry.message
        if msg.startswith("INFO"):
            continue

        # If there is an unresolved/undefined entity,
        # warn about it:
        if is_entity_error(msg):
            warnings.warn_explicit(msg,
                                   category=Warning,
                                   filename=entry.filename,
                                   lineno=entry.line,
                                   )
            all_warnings.append(ExitCode.entities)

        # Anything related to unresolved <xi:include/> elements:
        if msg.startswith("WARN"):
            warnings.warn_explicit(msg[6:],
                                   category=Warning,
                                   filename=entry.filename,
                                   lineno=entry.line,
                                   )
            all_warnings.append(ExitCode.xinclude)
        else:
            print("Good")

    result = set(all_warnings)

    return result.pop() if len(result) == 1 else ExitCode.ok


def print_error_log(error):
    """Prints error informations

    :param error: error exception traceback
    """
    print("ERROR: %s" % error, file=sys.stderr)
    if hasattr(error, 'error_log'):
        print(textwrap.indent(str(error.error_log),
                              prefix="       "),
              file=sys.stderr
              )


def check_wellformedness(xmlfile,
                         warnings_as_errors=False,
                         xinclude=True) -> int:
    """Checks a file for well-formedness

    This only works with lxml >= 3.4.0 (because of collect_ids option)

    :param str xmlfile: filename to XML file
    :param bool xinclude: do xinclude processing (default: True) or not
    :return: 0 (everything ok) or != 0 (some problem)
    :rtype: int
    """
    # We don't want to collect all IDs to avoid problems when
    # IDs are non-unique:
    xmlparser = etree.XMLParser(collect_ids=False)
    try:
        tree = etree.parse(xmlfile, parser=xmlparser)

        # The script only continues if there are no parser errors
        # (including undeclared entities)
        result = 0
        if xinclude:
            result = process_transform_output(process_xinclude(tree))
        return result

    except OSError as err:
        print_error_log(err)
        return ExitCode.file_not_found.value

    except etree.XMLSyntaxError as err:
        print_error_log(err)
        # for item in ("args", "code", "error_log", "filename", "lineno",
        #             "msg", "offset", "position",
        #             "print_file_and_line",
        #             "text", "with_traceback",
        #             ):
        #    print(f"  {item} => {getattr(err, item)}")
        if is_entity_error(err.msg):
            return ExitCode.entities.value
        # elif is_syntax_error(err.msg):
        else:
            return ExitCode.syntax.value

    except etree.XIncludeError as err:
        print_error_log(err)
        return ExitCode.xinclude.value


def parse_cli(args=None) -> argparse.Namespace:
    """Parse CLI arguments

    :param list args: Use the list or sys.args
    :return: parsed arguments
    :rtype: :class:`argparse.Namespace`
    """
    parser = argparse.ArgumentParser(description=__doc__.split("\n", 1)[0],
                                     epilog=__doc__.split("\n", 1)[-1],
                                     )
    parser.add_argument("--version",
                        action="version",
                        version="%(prog)s {}".format(__version__),
                        )
    parser.add_argument("--xinclude",
                        action="store_true",
                        default=False,
                        help="Do XInclude processing"
                        )
    parser.add_argument("-W", "--warnings-as-errors",
                        action="store_true",
                        default=False,
                        help=("Flag to set the behavior when "
                              "referenced files with XIncludes cannot "
                              "be found; "
                              "(default: %(default)s)")
                        )
    parser.add_argument("-S", "--stats",
                        action="store_true",
                        default=False,
                        help=("Print statistic about successful/"
                              "failed files"
                              )
                        )
    parser.add_argument("xmlfiles",
                        nargs="+",
                        help="XML file(s) to check for well-formedness"
                        )
    args = parser.parse_args(args)
    # print(args, file=sys.stderr)
    return args


def main(cliargs=None):
    """Entry point for the application script

    :param list cliargs: Arguments to parse or None (=use :class:`sys.argv`)
    :return: error code; 0 => everything was succesfull, !=0 => error
    :rtype: int
    """
    endresult = 0
    failures = 0
    successes = 0

    args = parse_cli()

    for xmlfile in args.xmlfiles:
        result = check_wellformedness(xmlfile,
                                      args.warnings_as_errors,
                                      args.xinclude
                                      )
        # print("+++++", result)
        if result and args.warnings_as_errors:
            break
        if result:
            failures += 1
        else:
            successes += 1
        endresult += result

    if args.stats:
        msg = (f"--- Successful Files={successes}, "
               f"Failed files={failures} ---"
               )
        print(msg, file=sys.stderr)

    return endresult


if __name__ == "__main__":
    sys.exit(main())
