#!/bin/bash
#
# Copyright (C) 2012-2020 SUSE Software Solutions Germany GmbH
#
# Author:
# Frank Sundermeyer <fsundermeyer at opensuse dot org>
#
# DAPS = DocBook Authoring and Publishing Suite

MY_NAME=DAPS
VERSION=@PACKAGE_VERSION@
MY_URL=https://opensuse.github.io/daps

export MY_NAME VERSION MY_URL

# autoconf replaces @foo@ stuff with ${prefix}/.. if @foo@ has not
# explicitly been set, so we need to at least export prefix to
# be on the safe side

export prefix=@prefix@

#
# Do not even attempt to start, if we are in a directory that does not exist
# (fix for https://bugzilla.suse.com/show_bug.cgi?id=961526)

[[ -d $(pwd 2>/dev/null) ]] || {
    echo "Cannot operate from a directory that does not exist!"
    exit 1
    }

# ----------------------------------------------------------------------------
# VARIABLES
#
# First, list all variables we need to pass to make. They all need to be
# EXPORTED, but we do not want to write the export statement in the config
# files, so we need to have this list
#
# IMPORTANT
# All variables that need to be exported for further use in the makefiles
# need to be added here!!
#






declare -a VARLIST
VARLIST=(
    ADOC_ATTRIBUTES
    ADOC_BACKEND
    ADOC_FAILURE_LEVEL
    ADOC_POST
    ADOC_POST_STYLE
    ADOC_SET
    ADOC_SET_STYLE
    ADOC_TYPE
    ASCIIDOC
    ASSEMBLY_LANG
    BOOK
    BUILD_DIR
    CB_OPTIONS
    COLOR
    CONF_PREFIX
    CONVERT_OPTS_JPG
    CONVERT_OPTS_PNG
    DEBUG
    DAPSROOT
    DAPSROOT_DEFAULT
    DEF_FILE
    DIA_OPTIONS
    DOCBOOK4_PROFILE_URN
    DOCBOOK4_STYLE_URI
    DOCBOOK5_PROFILE_URN
    DOCBOOK5_RNG
    DOCBOOK5_RNG_URI
    DOCBOOK5_STYLE_URI
    DOCBOOK_STYLES
    DOCBOOK_VERSION
    DOCCONF
    DOCCONF_DEFAULT
    DRAFT
    DRAFT_STR
    EPUBCHECK
    EPUB_CSS
    FALLBACK_STYLEROOT
    FOP_CONFIG_FILE
    FOP_CMD_OPTIONS
    FOP_JAVA_FLAGS
    FOP_JAVA_JARS
    FOP_JAVA_OPTIONS
    FOP_WRAPPER
    FORCE_REBUILD
    FORMATTER
    GZIP_MAN
    HTML5
    HTML_CSS
    IMAGES_COLOR
    IMG_SRC_DIR
    IMG_VIEWER
    INK_OPTIONS
    IS_ASSEMBLY
    JING_JAVA_FLAGS
    JING_JAVA_JARS
    JING_JAVA_OPTIONS
    JING_WRAPPER
    LIB_DIR
    LIBEXEC_DIR
    LOG_DIR
    MAIN
    META
    META_STR
    OUTPUTNAME
    PRJ_DIR
    PROFARCH
    PROFAUDIENCE
    PROFCONDITION
    PROFCONFORMANCE
    PROFILE_URN
    PROFLANG
    PROFOS
    PROFOUTPUTFORMAT
    PROFREVISION
    PROFREVISIONFLAG
    PROFROLE
    PROFSECURITY
    PROFSTATUS
    PROFUSERLEVEL
    PROFVENDOR
    PROFWORDSIZE
    REMARKS
    REMARK_STR
    RESULT_DIR
    ROOTID
    SPELL_CHECKER
    SPELL_EXTRA_DICT
    SPELL_LANG
    SPELL_SKIP_TAGS
    SRC_DIR
    SRC_FORMAT
    STATIC_DIR
    STRUCTID
    STYLEASSEMBLY
    STYLEDEVEL
    STYLEROOT
    TXT_IGNORE_STYLEROOT
    TXT_PARAMS
    VALID_ROOTELEMENTS
    VERBOSITY
    WH_SEARCH
    XEP_CONFIG_FILE
    XEP_CMD_OPTIONS
    XEP_JAVA_FLAGS
    XEP_JAVA_JARS
    XEP_JAVA_OPTIONS
    XEP_WRAPPER
    XML_CATALOG_FILES
    XMLFORMAT_CONFIG_FILE
    XML_MAIN_CATALOG
    XML_USER_CATALOGS
    XSLTPARAM
    XSLTPROC
    XSLTPROCESSOR
)
# unset all for a fresh start, but preserve $DOCCONF - it might have been set
# by having sourced a DC-file

[[ -n "$DOCCONF" ]] && DOCCONF_SAVE=$DOCCONF
unset "${VARLIST[@]}"
[[ -n "$DOCCONF_SAVE" ]] && DOCCONF=$DOCCONF_SAVE


# The following UNSETLIST contains variables local to this script
# To be on the safe side, we also want to unset a few variables before we start
# because they are used/defined in make or may cause other harm if accidentally
# set
#
declare -a UNSETLIST
UNSETLIST=(
    ADOC_SET_CMDL
    BIN_DIR
    BUILD_DIR_CMDL
    COLOR_CMDL
    CONFIG
    DC_PATH_EXISTS
    DOCBOOK5_RNG_URI_CMDL
    DOCCONF_NAME
    FALLBACK_STYLEROOT_CMDL
    HELP_SUBCMD
    MAIN_CMDL
    R_DIR
    STYLEROOT_CMDL
    VERBOSITY_CMDL
)
unset "${UNSETLIST[@]}"

# PATHLIST contains all variables holding a path. Relative paths need to be
# made absolute and we need this list in order to know which variables hold
# path information
#
# This list must not include FALLBACK_STYLEROOT, since we allow multiple
# values here.
# TODO: Check multiple FALLBACK_STYLEROOT paths
#
declare -A PATHLIST
PATHLIST=(
  [SPELL_EXTRA_DICT]="additional spell dictionary"
  [BUILD_DIR]="build directory"
  [DAPSROOT]="DAPS root directory"
  [DOCCONF]="DC-file"
  [DOCCONF_DEFAULT]="default DC-file"
  [EPUB_CSS]="CSS file for EPUB"
  [FOP_CONFIG_FILE]="FOP configuration file"
  [FOP_WRAPPER]="FOP wrapper script"
  [HTML_CSS]="CSS file for HTML"
  [IMG_SRC_DIR]="directory for the image source files"
  [JING_WRAPPER]="Jing wrapper script"
  [MAIN]="MAIN-file"
  [SRC_DIR]="directory for the adoc or xml source files"
  [STATIC_DIR]="HTML resource directory"
  [STYLEDEVEL]="development directory for stylesheets"
  [STYLEROOT]="stylesheet directory"
  [XEP_CONFIG_FILE]="XEP configuration file"
  [XEP_WRAPPER]="XEP wrapper script"
  [XMLFORMAT_CONFIG_FILE]="xmlformat configuration file"
)

# ----------------------------------------------------------------------------
# We need to set some basic defaults outside of $DEFAULT_CONFIG

# this script's name
ME=$(basename "$0")

# default config file
DEFAULT_CONFIG="@sysconfdir@/daps/config"

# The default DAPSROOT
DAPSROOT_DEFAULT="@pkgdatadir@"

# default libdir
DEFAULT_LIB_DIR="${DAPSROOT_DEFAULT}/lib"
DEFAULT_LIBEXEC_DIR="${DAPSROOT_DEFAULT}/libexec"


# Config files
# ------------
# By default USER_CONFIG is parsed
# if DAPS_CONFIG_FILE is set (via --config on the command line),
# USER_CONFIG is ignored
# The file that is parsed in the end is stored in CONF_TO_PARSE
#
USER_CONFIG_OLD="$HOME/.daps/config"
USER_CONFIG="$HOME/.config/daps/dapsrc"
CONF_TO_PARSE=""

# if run from a terminal, set default verbosity to 1, otherwise (script, pipe)
# set it to 0

if [[ -t 1 ]]; then
    VERBOSITY=1
else
    VERBOSITY=0
fi

# Set the maximum number of concurrent jobs to the number of cores
# If grep -E does not return something useful, set it to "2" as a sane default
JOBS=$(grep -E -s -m1 "cpu cores\s*:" /proc/cpuinfo 2>/dev/null | sed 's/cpu cores\s*:\s*//')
[[ -z $JOBS ]] && JOBS=2

#---------------------------------------------------
# SUBCOMMANDS
#
# Associative Array
#  Key   = subcommand
#  Value = function call (from lib/daps_functions)
#
#
# The subcommands can be executed using:
#   ${SUBCOMMANDS[$SUBCMD]} $SUBCMD ${SCMD_ARGS[@]}
# Using such an array rather than a function to call the subcommands has
# the advantage that we can very easily check whether a subcommand is valid
# or not by just testing if ${SUBCOMMANDS[$SUBCMD]} is set

declare -A SUBCOMMANDS
declare -A HELP_SUBCOMMAND

SUBCOMMANDS[bigfile]="bigfile"
HELP_SUBCOMMAND[bigfile]="Creates a single XML file (bigfile) from the MAIN-file referenced in the\nDC-file or specified on the command line by following all xi:includes.\nIf a ROOTID is specified, all xref-links pointing to locations outside the\nscope defined by the ROOTID, are replaced by text-links."

SUBCOMMANDS[clean]="no_opts"
HELP_SUBCOMMAND[clean]="Removes all profiled XML sources and temporary files generated by DAPS."

SUBCOMMANDS[clean-all]="no_opts"
HELP_SUBCOMMAND[clean-all]="Removes all data (documents, images, logfiles, profiled XML, ...) generated\nby DAPS."

SUBCOMMANDS[clean-images]="no_opts"
HELP_SUBCOMMAND[clean-images]="Removes the results of all image conversions generated by DAPS."

SUBCOMMANDS[clean-package]="no_opts"
HELP_SUBCOMMAND[clean-package]="Removes all generated package data for a given DC- or MAIN-file.\nImage conversion results and profiled XML sources will not be deleted."

SUBCOMMANDS[clean-results]="no_opts"
HELP_SUBCOMMAND[clean-results]="Removes all generated documents and logfiles for a given DC- or MAIN-file.\nImage conversion results and profiled XML sources will not be deleted."

SUBCOMMANDS[dapsenv]="debugging"
HELP_SUBCOMMAND[dapsenv]="DEBUGGING: Shows a list of internal variables and their values."

SUBCOMMANDS[dist-webhelp]="build_generic"
HELP_SUBCOMMAND[dist-webhelp]="Creates a distributable tar archive of a webhelp document\n(including images and css)."

SUBCOMMANDS[dist-webhelp-name]="show_names"
HELP_SUBCOMMAND[dist-webhelp-name]="Print the file name that would result when building a distributable tar archive\nof a webhelp document."

SUBCOMMANDS[docinfo]="build_generic"
HELP_SUBCOMMAND[docinfo]="Print information such as title, language, etc on a book or article."

SUBCOMMANDS[epub]="build_epub"
HELP_SUBCOMMAND[epub]="Build an eBook from the XML sources."

SUBCOMMANDS[epub-name]="show_names"
HELP_SUBCOMMAND[epub-name]="Print the file name that would result when building an eBook."

SUBCOMMANDS[getimages]="getimages"
HELP_SUBCOMMAND[getimages]="List and/or display images (in a viewer of your choice) referenced in an\nXML file or by rootid."

SUBCOMMANDS[html]="build_html"
HELP_SUBCOMMAND[html]="Build an HTML document from the XML sources."

SUBCOMMANDS[html-dir-name]="show_names"
HELP_SUBCOMMAND[html-dir-name]="Print the directory name that would result when building an HTML book."

SUBCOMMANDS[images]="build_images"
HELP_SUBCOMMAND[images]="Generate images for the given document."

SUBCOMMANDS[linkcheck]="linkcheck"
HELP_SUBCOMMAND[linkcheck]="Validates ftp and http(s) links in XML sources."

SUBCOMMANDS[list-file]="filelists"
HELP_SUBCOMMAND[list-file]="Lists the filename that contains the ID specified with --rootid."

SUBCOMMANDS[list-images-missing]="filelists"
HELP_SUBCOMMAND[list-images-missing]="Prints a list of images that are referenced in the XML sources but are missing\nin the images' source directory."

SUBCOMMANDS[list-images-multisrc]="filelists"
HELP_SUBCOMMAND[list-images-multisrc]="List images for which multiple sources exist."

SUBCOMMANDS[list-srcfiles]="filelists"
HELP_SUBCOMMAND[list-srcfiles]="List all source files used to build the document specified by\nthe DC-file (XML-files, images, entity declarations, DC-file).\nUse the --no* options to exclude certain types."

SUBCOMMANDS[list-srcfiles-unused]="filelists"
HELP_SUBCOMMAND[list-srcfiles-unused]="Print a list of all source XML files from the xml directory\n and images from the image source directory _not_ used in the document referenced by the DC- or MAIN-file."

SUBCOMMANDS[locdrop]="build_locdrop"
HELP_SUBCOMMAND[locdrop]="Create all tar archives required to distribute a complete set for translation.\nRequires DocBook 5 document with <info><dm:docmanager><dm:translation>yes</dm:translation></dm:docmanager></info> element."

SUBCOMMANDS[man]="build_man"
HELP_SUBCOMMAND[man]="Build one or more man pages from suitable XML sources. All <refentry> parts\nfrom the source file(s) will be transformed to man pages."

SUBCOMMANDS[man-dir-name]="show_names"
HELP_SUBCOMMAND[man-dir-name]="Print the directory name that would result when building man pages."

SUBCOMMANDS[mobi]="build_epub"
HELP_SUBCOMMAND[mobi]="Build an eBook for Amazon Kindle readers from the XML sources."

SUBCOMMANDS[mobi-name]="show_names"
HELP_SUBCOMMAND[mobi-name]="Print the file name that would result when building an Amazon Kindle book."

SUBCOMMANDS[nothing]="debugging"
HELP_SUBCOMMAND[nothing]="DEBUGGING: Benchmarking target."

SUBCOMMANDS[optipng]="build_generic"
HELP_SUBCOMMAND[optipng]="Reduce the size of the source PNG images using 'optipng'.\nNOTE: This command will directly alter your source images!"

SUBCOMMANDS[package-html]="package-html"
HELP_SUBCOMMAND[package-html]="Create all archives and files needed for packaging an\nHTML document (chunked HTML or single HTML)."

SUBCOMMANDS[package-html-dir-name]="show_names"
HELP_SUBCOMMAND[package-html-dir-name]="Print the directory name that would result when building\nan html package."

SUBCOMMANDS[package-pdf]="package-pdf"
HELP_SUBCOMMAND[package-pdf]="Create all archives and files needed for packaging a PDF document."

SUBCOMMANDS[package-pdf-dir-name]="show_names"
HELP_SUBCOMMAND[package-pdf-dir-name]="Print the directory name that would result when building\na pdf package."

SUBCOMMANDS[package-src]="package-src"
HELP_SUBCOMMAND[package-src]="creates a distributable source archive containg the profiled sources of the complete set\nincluding the original source images."

SUBCOMMANDS[package-src-name]="show_names"
HELP_SUBCOMMAND[package-src-name]="Print the file name that would result when building a distributable source\narchive."

SUBCOMMANDS[pdf]="build_pdfs"
HELP_SUBCOMMAND[pdf]="Build a PDF document from the XML sources."

SUBCOMMANDS[pdf-name]="show_names"
HELP_SUBCOMMAND[pdf-name]="Print the file name that would result when building a grayscale PDF document."

SUBCOMMANDS[productinfo]="build_generic"
HELP_SUBCOMMAND[productinfo]="Print the contents of the tags <productname> and <productnumber for the given ROOTID."

SUBCOMMANDS[profile]="build_generic"
HELP_SUBCOMMAND[profile]="Create profiled souces from the original XML sources. If the MAIN-file does\nnot contain profiling instructions, link the files into the profile directory."

SUBCOMMANDS[real-clean]="no_opts"
HELP_SUBCOMMAND[real-clean]="Removes all data (documents, images, logfiles, profiled XML, ...) generated\nby DAPS"

SUBCOMMANDS[showenv]="showenv"
HELP_SUBCOMMAND[showenv]="DEBUGGING: Target reserved for daps-docmanager"

SUBCOMMANDS[showvariable]="debugging"
HELP_SUBCOMMAND[showvariable]="DEBUGGING: Show the value of a given variable.\nUsage: showvariable VARIABLE=<VARNAME>"

SUBCOMMANDS[spellcheck]="spellcheck"
HELP_SUBCOMMAND[spellcheck]="Spellchecks the file specified with --file or the document specified by rootid."

SUBCOMMANDS[stylecheck]="stylecheck"
HELP_SUBCOMMAND[stylecheck]="Performs a style check on the given DC-file or rootid."

SUBCOMMANDS[text]="build_text"
HELP_SUBCOMMAND[text]="Build an ASCII text document the from the XML sources. Text output is\ngenerated by creating a single file HTML page parsing the result with w3m."

SUBCOMMANDS[text-name]="show_names"
HELP_SUBCOMMAND[text-name]="Print the file name that would result when building an ASCII text document."

SUBCOMMANDS[unpack-locdrop]="unpack-locdrop"
HELP_SUBCOMMAND[unpack-locdrop]="Unpack a localization drop packages source."

SUBCOMMANDS[validate]="validate"
HELP_SUBCOMMAND[validate]="Validate the profiled XML sources referenced by the DC- or MAIN-file."

SUBCOMMANDS[webhelp]="webhelp"
HELP_SUBCOMMAND[webhelp]="Build an HTML document with a table of contents/search frame (aka webhelp)\nfrom the XML sources."

SUBCOMMANDS[webhelp-dir-name]="show_names"
HELP_SUBCOMMAND[webhelp-dir-name]="Print the directory name that would result when building a webhelp document."

SUBCOMMANDS[xmlformat]="xmlformat"
HELP_SUBCOMMAND[xmlformat]="Prettify XML sources using the xmlformat program.\n The default configuration files are included with DAPS (/etc/daps/docbook-xmlformat-*.conf)."

# ----------------------------------------------------------------------------
# FUNCTIONS
#
# We need to declare a few basic functions first because they are needed
# immediately. All other functions can be found at
# $DAPSROOT/lib/daps-functions
# ---------
# Help
#

function daps_help {
    cat <<EOF_helptext
Usage:
  1. $ME -d DC-file [--options] <subcommand> [--subcommand-options]
  2. $ME -m MAIN file [--options] <subcommand> [--subcommand-options]


Global Options:
  --adocattr="NAME=VALUE"   Overwrite, define or delete an AsciiDoc document
                            attribute. To overwrite an attribute already
                            defined in the AsciiDoc document, use NAME=VALUE,
                            or just NAME for attributes without a value. To delete
                            a value set in the document use NAME!. To set
                            a value that is not already set in the document, use
                            NAME=VALUE@.
                            Default: unset
                            This option can be specified multiple times. Only
                            works with AsciiDoc sources and is ignored otherwise.
  --adocset                 If specified, DAPS tries to convert the AsciiDoc
                            document into a set. Requires an AsciiDoc document
                            that consists of parts (each part will be
                            converted into a book in a set),
                            Default: unset
  --builddir=BUILD_DIR      Directory where every output $ME generates will
                            end up.
                            Default: <doc dir>/build/
  --color=(0|1)             By default errors, results, warnings and certain
                            info messages are printed in color using bash color
                            codes. Set to '0' to turn off colors.
                            Default: 1 (when the output does not go to a
                                        terminal, colored output will be
                                        disabled automatically)
  --config=CFG-FILE         Set a configuration file for DAPS that overwrites
                            defaults set in /etc/daps/config.
                            By default (when this option is not set)
                            ~/.config/daps/dapsrc will be parsed, if existing.
                            In case --config is set, ~/.config/daps/dapsrc
                            will be ignored.
                            Default: ~/.config/daps/dapsrc
  --commands                Show a list of available DAPS sub commands
  --debug                   Print debugging messages. Alternatively see the
                            verbosity options for an output that is better
                            readable.
  --docconfig=DC-file,
  -d DC-file                Path to doc config file to use. Mandatory,
                            unless there is only a single DC-file in the
                            current directory or unless you have configured a
                            default value (DOCCONF_DEFAULT) in \$USER_CONFIG.
                            Note: Options --docconfig and --main exclude
                                  each other.
  --fb_styleroot=DIR        Fallback styleroot directories. Can only be used in
                            conjunction with --styleroot. By default, the
                            DocBook stylesheets are used as a fallback if
                            custom styles for an output format are not present.
                            With this option you can specify a list of
                            alternative fallbacks (space separated absolute
                            paths). The directories will be tested in the order
                            specified, the first one that applies to the
                            requested format, will be used. The original
                            DocBook stylesheets will be used as a last resort.
                            Useful if you have forks of your custom
                            stylesheets.
  --force                   Force a rebuild of the document even when an
                            up-to-date version exists. This is the default.
                            If the config was changed to not rebuild
                            (ALWAYS_REBUILD="no"), use this option to override.
  --help, -h                Help
  --imgsrcdir=IMG_SRC_DIR   Specify a directory for the images used in the
                            sources. Must contain all images, either in the
                            specified directory, or in subdirectories carrying
                            the name of the supported formats
                            (jpg/, png/, svg/, ...)
                            Default: images/src/{dia,ditaa,jpg,odg,pgn,svg}
  --jobs=X                  Specify how many parallel jobs to use. Higher
                            numbers will significantly increase the processing
                            speed, but will also set your machine under heavy
                            load, up to a point where it may become
                            (temporarily) unresponsive.
                            Default: Use as man jobs as available CPU cores.
  --main=MAIN
  -m MAIN                   Path to the main file defining your document.
                            Note: Options --main and --docconfig exclude
                                  each other.
  --schema=URN              URN to a DocBook 5 schema that is to be used for
                            validation. Will be ignored when validating
                            DocBook 4 documents.
                            Note: To validate with a local schema, specify an
                                  absolute path with a "file://" prefix
                                  (e.g. "file:///foo/schema.rnc").
  --srcdir=SRC_DIR          Specify a directory for the xml or adoc source
                            files. Must contain all respective source files
                            for the the project.
                            It is not necessary to specify this option when
                            using --main.
                            Default: $PRJ_DIR/xml or $PRJ_DIR/adoc, depending
                                     on the source format
  --styleroot=DIR           By default, daps uses the DocBook stylesheets to
                            create output. If you have your own set of
                            stylesheets, specify the absolute path to the
                            stylesheet directory here. The DocBook stylesheets
                            will be used as a fallback in case styles are not
                            defined for all output formats.
  --verbosity=0, -v0        Verbosity Level 0 (print 1 line of results)
  --verbosity=1, -v1, -v    Verbosity Level 1 (print intermediate results)
  --verbosity=2, -v2, -vv   Verbosity Level 2 (print all files created)
  --verbosity=3, -v3, -vvv  Verbosity Level 3 (print all commands, very
                            verbose)
  --version                 Print version number
  --xsltprocessor=PROCESSOR Specify an XSLT processor that is used to transform
                            the XML files. Currently supported are "xsltproc"
                            and "saxon" (version 6).
                            Default: xsltproc

Subcommands:
   help                       Print this help.

  Generate Books:
    epub                      ePUB book
    html                      HTML book (chunked or single file HTML)
    man                       man pages
    mobi                      Amazon Kindle eBook
    pdf                       PDF book (color, grayscale, printable)
    text                      ASCII book
    webhelp                   HTML book with collapsible TOC and search


  File lists:
    list-file                 Lists the filename that contains the ID specified
                              with the mandatory parameter --rootid.
    list-srcfiles             List source files (XML sources, images, entity
                              declarations, DC-file) used by the document
                              reference by the DC-file.
    list-srcfiles-unused      List files from the document and image source and
                              directories not used by the document reference
                              by the DC-file.
    list-images-missing       List images referenced in the XML sources but
                              missing in the images' source directory.
    list-images-multisrc      List images for which multiple sources exist
                              (e.g. foo.svg and foo.png).

  Cleaning up:
    clean                     Remove all profiled sources and temporary files.
    clean-images              Remove all generated images.
    clean-package             Remove all generated package data for the given
                              DC-file. Generated images and profiled sources
                              will _not_ be deleted.
    clean-results             Remove all generated books, archives, and log
                              files for the given DC-file. Generated images
                              and profiled sources will _not_ be deleted.
    clean-all, real-clean     Remove everything generated by $ME.

  Packaging:
    package-html              Provide an HTML tarball (chunked HTML or
                              single HTML), desktop, document,
                              and/or page files (for KDE and GNOME).
    package-pdf               Provide a PDF, desktop, document, and/or
                              page files (for KDE and GNOME).
    package-src               Provide profiled XML sources and graphics

  Deploying:
    locdrop                   Provide everything that is needed to translate a
                              set.
    unpack-locdrop            Unpack a localization drop packages source.

  Other Commands:
    getimages                 List or display images from a profiled DocBook
                              XML file.
    linkcheck                 Link checker for links from <ulink> tags
    optipng                   Optimize file size of source PNGs.
    profile                   Profile XML sources.
    spellcheck                Spellchecks the file specified with --file or the
                              document specified by rootid.
    stylecheck                Performs a style check on the given DC-file or
                              rootid.
    validate                  Validate profiled sources. Automatically profiles
                              the XML sources if needed.
    xmlformat                 Prettify the XML source files using
                              daps-xmlformat.

  File and Directory Names:
    <target>-name             Print resulting file name for <target>. <target>
                              may be one of color-pdf, epub, html-single,
                              pdf, txt.
    <target>-dir-name         Print resulting directory name for <target>.
                              <target> may be html, man or webhelp.

  Debugging:
    bigfile                   Creates a single "big" XML file by resolving
                              xi:includes. Useful for detecting validation
                              errors that cannot be found otherwise.
    dapsenv                   Print a list of the most important make variables
                              and their value.
    docinfo                   Print information such as title, language, etc
                              on a book or article.
    images                    Generates all images for the given DC-file or
                              rootid.
    showvariable              Print value of a given make variable:
                              $ME showvariable VARIABLE=<MAKE_VARIABLE>.

Type '$ME <subcommand> -h' for help on a specific subcommand.
EOF_helptext
}

function daps_commands {
    # show a list of available subcommands from the SUBCOMMANDS array
    # ignore the commands set to deprecated
    local KEY

    for KEY in "${!SUBCOMMANDS[@]}"; do
        #if [[ deprecated == "${SUBCOMMANDS[$KEY]}" ]]; then
        #    continue
        #else
        #    echo "$KEY"
        #fi
        echo "$KEY"
    done | sort -u
}

# ---------
# Clean up
#
function clean_daps {
    [[ -f $SETFILES_TMP ]] && rm -f "$SETFILES_TMP"
}

# ---------
# Verbose error handling
#
function exit_on_error {
    echo -e "ERROR: ${1}" >&2
    clean_daps
    exit 1;
}

# ---------
# Get absolute path, remove trailing / and test if path is valid
#
function sanitize_path {
    # Takes values
    # $1 = path
    # $2 = variable name holding $1
    # $3 = additional base dir for $1 (optional)
    #
    # sets absolute path without trailing / for $1, links are being followed
    # also tests if paths are valid
    #
    # in case of a non-existing path, returns 2 if variable name matches
    # _WRAPPER, else returns 1
    #
    local ABSPATH BASEDIR MYPATH ORIGIN_TEXT VARNAME VN WRONGPATH

    MYPATH=$1
    VARNAME=$2
    [[ -n "$3" ]] && BASEDIR=$3

    WRONGPATH=0

        # Do nothing if $1 is an empty value
    [[ -z "$MYPATH" ]] && return

    # Remove preceding file:// scheme
    if [[ ${MYPATH:0:5} = file: ]]; then
        MYPATH=${MYPATH#file:}
    fi

    # ignore values that need to be set by configure
    # (makes it possible to directly use a Git clone)
    [[ $MYPATH =~ @[a-zA-Z]*@ ]] && return

    # 1. Remove trailing Slash
    #
    MYPATH=${MYPATH%/} # remove trailing slash

    if [[ $MYPATH =~ ^~.* ]]; then
        # 2. Replace ~/ with $HOME
        if [[ $MYPATH =~ ^~/.* ]]; then
            MYPATH=${MYPATH/#\~\//$HOME/}
        else
            # 3. Replace ~USER with a real path
            # the %q option to printf quotes and escapes dangerous characters
            # see http://stackoverflow.com/questions/2069467/have-to-determine-all-users-home-directories-tilde-scripting-problem
            eval MYPATH="$(printf "%q" "$MYPATH")"
        fi
    fi

    if [[ "/" != ${MYPATH:0:1} ]]; then
        [[ -n "$BASEDIR" ]] && MYPATH="${BASEDIR}/${MYPATH}"
        ABSPATH=$(readlink -en "$MYPATH")
        if [[ 0 -eq $? ]]; then
            declare -g $VARNAME="$ABSPATH"
        else
            WRONGPATH=1
        fi
    else
        # path is already absolute, set to MYPATH (because of having cut
        # the trailing /
        if [[ -d $MYPATH || -f $MYPATH ]]; then
            declare -g $VARNAME="$MYPATH"
        else
            WRONGPATH=1
        fi
    fi

    # in case of a wrong path
    if [[ 1 -eq $WRONGPATH ]]; then
        # remove _CMDL from variable name if exists
        # MAIN_CMDL => MAIN
        if [[ $VARNAME =~ _CMDL ]]; then
            VN="${VARNAME%_CMDL}"
            ORIGIN_TEXT="(provided on the command line: $MYPATH)"
        else
            VN="${VARNAME}"
            ORIGIN_TEXT="(provided via config file: $VARNAME=$MYPATH)"
        fi
        # if an entry in PATHLIST exists, use the variable name
        # description provided in the associative array
        # to get a better error message
        if [ ${PATHLIST[$VN]+_} ]; then
            exit_on_error "Wrong path for the ${PATHLIST[$VN]}\n       ${ORIGIN_TEXT}"
        else
            exit_on_error "$VARNAME=$MYPATH: Path does not exist"
        fi
    fi
}

# ----------------------
# Check all paths in $PATHLIST with sanitize_path
#
function check_pathlist {
    local _PATH BASEDIR VNAME
    BASEDIR=$1
    for VNAME in "${!PATHLIST[@]}"; do
        _PATH="${!VNAME}"
        if [[ -n "$_PATH" ]]; then
            sanitize_path "$_PATH" "$VNAME" "$BASEDIR"
        fi
    done
}

# ---------
# Recover command-line values
#
function recover_cmdl_values {
    # adoc attributes is special because it can be specified multiple times
    # we want to keep all values
    test -n "$ADOC_ATTRIBUTES_CMDL"  && ADOC_ATTRIBUTES="$ADOC_ATTRIBUTES $ADOC_ATTRIBUTES_CMDL"
    test -n "$ADOC_SET_CMDL"         && ADOC_SET="$ADOC_SET_CMDL"
    test -n "$BUILD_DIR_CMDL"        && BUILD_DIR="$BUILD_DIR_CMDL"
    test -n "$COLOR_CMDL"            && COLOR="$COLOR_CMDL"
    test -n "$DOCBOOK5_RNG_URI_CMDL" && DOCBOOK5_RNG_URI="$DOCBOOK5_RNG_URI_CMDL"
    test -n "$FALLBACK_STYLEROOT_CMDL" && FALLBACK_STYLEROOT="$FALLBACK_STYLEROOT_CMDL"
    test -n "$IMG_SRC_DIR_CMDL"      && IMG_SRC_DIR="$IMG_SRC_DIR_CMDL"
    test -n "$MAIN_CMDL"             && MAIN="$MAIN_CMDL"
    test -n "$SRC_DIR_CMDL"          && SRC_DIR="$SRC_DIR_CMDL"
    test -n "$STYLEROOT_CMDL"        && STYLEROOT="$STYLEROOT_CMDL"
    test -n "$VERBOSITY_CMDL"        && VERBOSITY="$VERBOSITY_CMDL"
    test -n "$XSLTPROCESSOR_CMDL"    && XSLTPROCESSOR="$XSLTPROCESSOR_CMDL"
}

# ---------
# Config file parser for DC-files and general configs
# More secure than just sourcing the config files
#

function parse_config {

    # Inspired by
    # https://stackoverflow.com/questions/16571739/bash-parsing-variables-from-config-file
    # Takes the config file to parse as required value
    #
    [[ -z $1 ]] && exit_on_error "Function parse_config must be called with a config file as an argument"

    local CFG CONCAT KEY LINE_NO OLD_IFS VALUE

    CFG=$1
    LINE_NO=0
    OLD_IFS="$IFS"
    shopt -s extglob
    while IFS='= ' read KEY VALUE; do
        # no cocatenation by default
        CONCAT=0
        let LINE_NO++
        # skip empty lines
        [[ -z "$KEY" ]] && continue
        # skip comments
        [[ "$KEY" =~ ^[[:space:]]*# ]] && continue
        # skip export statements (were allowed in DAPS <= 2.2.0)
        [[ "$KEY" =~ ^[[:space:]]*export$ ]] && continue

        # Possible KEY/VALUE pairs
        # KEY01 = VALUE
        # KEY02=VALUE
        # KEY03 = "VALUE"
        # KEY04="VALUE"
        # KEY05 = VALUE   # comment
        # KEY06=VALUE     # comment
        # KEY07 = "VALUE" # comment
        # KEY08="VALUE"   # comment
        # KEY09 += VALUE
        # KEY10+=VALUE
        # KEY11 += "VALUE"
        # KEY12+="VALUE"
        # KEY13 += VALUE   # comment
        # KEY14+=VALUE     # comment
        # KEY15 += "VALUE" # comment
        # KEY16+="VALUE"   # comment
        # KEY17+="'VALUE17'"
        # KEY18+=""VAL\\\"UE18""
        # KEY19="  VALUE 19  "
        # KEY20="  VAL \\\#UE 20  "# # #  comment # ##
        # KEY21==VALUE
        # KEY22 == "VALUE"

        # not supported
        # KEY = "Val #ue"        use "Val \\\#ue" instead
        # KEY = "Val \#ue"       use "Val \\\#ue" instead
        # KEY = "c:\windows\foo" use "c:\\\windows\\\foo" instead

        # removing opening/closing single/double quotes from VALUE
        # ${string/#substring/replacement}
        # ${string%%substring}
        #
        VALUE="${VALUE%% \#*}"        # del inline right comments
        VALUE="${VALUE/#=/}"          # del leading "=" (allows k==v)
        VALUE="${VALUE%%*( )}"        # del trailing spaces
        VALUE="${VALUE/#[\"\'\`\´]/}" # del opening quotes and ticks
        VALUE="${VALUE/%[\"\'\`\´]/}" # del closing quotes and ticks

        # KEY += VALUE
        if [[ "$VALUE" =~ ^\+= ]]; then
            CONCAT=1
            VALUE="${VALUE#+=*}"      # del "+="
            VALUE="${VALUE##*( )}"    # del leading spaces
            VALUE="${VALUE/#[\"\'\`\´]/}" # del closing quotes and ticks
        # KEY+=VALUE
        elif [[ "$KEY" =~ \+$ ]]; then
            CONCAT=1
            KEY="${KEY%*+}"           # del trailing "+"
        fi

        # check if KEY is a valid variable name
        [[ "$KEY" =~ ^[_[:alpha:]][_[:alnum:]]*$ ]] || exit_on_error "Invalid key value \"$KEY\" in config-file $CFG:$LINE_NO"

        # set variables
        if [[ 1 -eq $CONCAT ]]; then
            if [[ -n "${!KEY}" ]]; then
                declare -g $KEY="${!KEY} $VALUE"
            else
                # += was used without previously setting the valiarble
                declare -g $KEY="$VALUE"
            fi
        else
            declare -g $KEY="$VALUE"
        fi

        # Warn on empty values
        if [[ "$VALUE" = "\"\"" || "$VALUE" = "''" ]]; then
            ccecho "warn" "Warning: Quotes-only value for \"$KEY\" in config-file $CFG:$LINE_NO"
        fi
    done < <(grep "" "$CFG")
    # above: see https://stackoverflow.com/questions/4165135/how-to-use-while-read-bash-to-read-the-last-line-in-a-file-if-there-s-no-new
    shopt -u extglob
    IFS="$OLD_IFS"
}



trap "exit_on_error '\nCaught SIGTERM/SIGINT'" SIGTERM SIGINT
trap "clean_daps" ERR EXIT

# ----------------------------------------------------------------------------
# Parsing the command line arguments with GNU getopt
#
# In order to separate general daps parameters from subcommand parameters,
# we are setting POSIXLY_CORRECT before parsing the first time.
# This causes getopt to interpret all remaining parameters as non-option
# parameters as soon as the first non-option parameter (the subcommand) is
# found. This value must be _exported_

export POSIXLY_CORRECT=1

# So, the first getopt go will parse all parameters listed directly after the
# daps command, leaving an array ($@) with the subcommand and it's
# parameters, which can be parsed in a second getopt go.

#-------------------------------
# Parsing the daps parameters
#
# If variables such as $BUILD_DIR, $DOCCONF, and $DAPSROOT are set via command
# line switch, we do not want to overwrite them by any other file we source
# at a later stage (command line always wins).
# Declaring the variables as read-only is unfortunately not an option, since
# every attempt to (un)set a read-only variable throws an error - something
# we do not want when sourcing a config file.
# Therefore we need to save each variable twice in order to recover the
# original value.

ARGS=$(getopt -o d:e:hm:v:: -l adocattr:,adocset,builddir:,config:,color:,colour:,commands,debug,docconfig:,dapsroot:,envfile:,fb_styleroot:,force,help,imgsrcdir:,jobs:,main:,schema:,srcdir:,styleroot:,verbosity::,version,xsltprocessor: -n "$ME" -- "$@")

# Exit when getopt returns errors
#
GETOPT_RETURN_CODE=$?
[[ 0 -ne $GETOPT_RETURN_CODE ]] && exit $GETOPT_RETURN_CODE

eval set -- "$ARGS"

while true ; do
    case "$1" in
        --adocattr)
            ADOC_ATTRIBUTES_CMDL="$ADOC_ATTRIBUTES_CMDL --attribute=\"$2\""
            shift 2
            ;;
        --adocset)
            ADOC_SET_CMDL="yes"
            ADOC_SET="$ADOC_SET_CMDL"
            shift
            ;;
        --builddir)
            [[ -d $2 ]] || exit_on_error "BUILD_DIR \"$2\" is not a valid directory"
            [[ -w $2 ]] || exit_on_error "BUILD_DIR \"$2\" is not writable"
            # make path absolute and strip trailing slash
            sanitize_path "$2" "BUILD_DIR_CMDL"
            BUILD_DIR="$BUILD_DIR_CMDL"
            shift 2
            ;;
        --config)
            [[ -s $2 ]] || exit_on_error "DAPS_CONFIG_FILE \"$2\" is not a valid file"
            # make path absolute and strip trailing slash
            sanitize_path "$2" "DAPS_CONFIG_FILE"
            shift 2
            ;;
        --color|--colour)
            if [[ 1 -ne $2 && 0 -ne $2 ]]; then
                exit_on_error "Wrong value ($2) for COLOR. Must be \"0\" or \"1\""
            fi
            COLOR_CMDL=$2
            export COLOR="$COLOR_CMDL"
            shift 2
            ;;
        --commands)
            daps_commands
            exit 0
            ;;
        -d|--docconfig|-e|--envfile)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "DOCCONF"
            shift 2
            ;;
        --dapsroot)
            [[ -d $2 ]] || exit_on_error "DAPSROOT \"$2\" is not a valid directory"
            # make path absolute and strip trailing slash
            sanitize_path "$2" "DAPSROOT"
            shift 2
            ;;
        --debug)
            # debug also implies VERBOSITY=2
            DEBUG=1
            VERBOSITY_CMDL=2
            VERBOSITY=$VERBOSITY_CMDL
            # enable JAVA debug messages (fop, xep)
            export VERBOSE=1
            shift
            ;;
        --fb_styleroot)
            # We are allowing multiple values, space-seperated
            for FBS in $2; do
                # make path absolute and strip trailing slash
                sanitize_path "$FBS" "FBS_LIST"
                FALLBACK_STYLEROOT_CMDL="$FALLBACK_STYLEROOT_CMDL $FBS_LIST"
            done
            FALLBACK_STYLEROOT="$FALLBACK_STYLEROOT_CMDL"
            shift 2
            ;;
        --force)
            FORCE_REBUILD=1
            shift
            ;;
        -h|--help)
            # if it's just "-h/--help", then print the global daps help
            # if "-h/--help" is followed by a subcommand, then set a marker
            # to call the subcommand's help
            shift;
            if [[ "" = "$2" ]]; then
                daps_help
                exit 0;
            else
                CALL_SCMDHELP=1
            fi
            ;;
        --imgsrcdir)
            [[ -d $2 ]] || exit_on_error "IMG_SRC_DIR \"$2\" is not a valid directory"
            # strip trailing slash (if any)
            IMG_SRC_DIR_CMDL=${2%/}
            IMG_SRC_DIR="$IMG_SRC_DIR_CMDL"
            shift 2
            ;;
        --jobs)
            if [[ $2 =~ ^[0-9][0-9]*$ ]]; then
                JOBS="$2"
            else
                exit_on_error "Wrong value ($2) for --jobs. Must be a numeric"
            fi
            shift 2
            ;;
        -m|--main)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "MAIN_CMDL"
            MAIN="$MAIN_CMDL"
            shift 2
            ;;
        --schema)
            DOCBOOK5_RNG_URI_CMDL="$2"
            DOCBOOK5_RNG_URI="$DOCBOOK5_RNG_URI_CMDL"
            shift 2
            ;;
        --srcdir)
            [[ -d $2 ]] || exit_on_error "SRC_DIR \"$2\" is not a valid directory"
            # strip trailing slash (if any)
            SRC_DIR_CMDL=${2%/}
            SRC_DIR="$SRC_DIR_CMDL"
            shift 2
            ;;
        --styleroot)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "STYLEROOT_CMDL"
            STYLEROOT="$STYLEROOT_CMDL"
            shift 2
            ;;
        -v|--verbosity)
            # $VERBOSITY will be parsed in the makefiles
            # VERBOSITY=0: print only final results message (default)
            # VERBOSITY=1: results of each target that is called
            # VERBOSITY=2: detailed output of each target
            #
            if [[ 1 -eq $DEBUG ]]; then
                VERBOSITY_CMDL=2
            else
                if [[ 0 = "$2" ]]; then
                    VERBOSITY_CMDL=0
                elif [[ 1 = "$2" || "" = "$2" ]]; then
                    VERBOSITY_CMDL=1
                elif [[ 2 = "$2" || "v" = "$2" ]]; then
                    VERBOSITY_CMDL=2
                else
                    VERBOSITY_CMDL=3
                fi
            fi
            VERBOSITY="$VERBOSITY_CMDL"
            shift 2
            ;;
        --version)
            echo "$ME $VERSION"
            exit 0
            ;;
        --xsltprocessor)
            which "$2" >/dev/null 2>&1 || exit_on_error "Cannot find the XSLT processor \"$2\"."
            XSLTPROCESSOR_CMDL="$2"
            XSLTPROCESSOR="$XSLTPROCESSOR_CMDL"
            shift 2
            ;;
        --) shift ; break ;;
        *) exit_on_error "Internal error!" ;;
    esac
done
#-----------------------------------
# Perform first checks
#

# You can only specify DOCCONF or MAIN, not both
#
if [[ -n "$MAIN_CMDL" ]]; then
    [[ -n "$DOCCONF" ]] && exit_on_error "The options -d/--docconfig and --main exclude each other."
fi

# Check FALLBACK_STYLEROOT and STYLEROOT
#
if [[ -n "$FALLBACK_STYLEROOT" && -z "$STYLEROOT" ]]; then
    if [[ 0 -ne $VERBOSITY ]]; then
        echo "Warning: --styleroot is not specified, ignoring --fb_styleroot" >&2
    fi
fi

unset POSIXLY_CORRECT # we want the regular getopts behaviour on the second run

#-----------------------------------
# Store the subcommand and it's args
#
# extract the subcommand from $@ if $ME has been called with no arguments
# or with "help" as the only argument, run global help. If it was called with
# SUBCOMMAND help or help SUBCOMMAND, rewrite the command so the subcommand
# help is displayed.

if [[ -z "$1" ]] || [[ help = "$1" && -z "$2" ]]; then
    # Call: "$ME" or "$ME help"
    #
    daps_help
    exit 0
elif [[ help = "$2" ]]; then
    # Call: "$ME foo help ..."
    # Rewrite to "$ME foo -h"
    #
    SUBCMD=$1
    declare -a SCMD_ARGS=( "-h" )
elif [[ help = "$1" && -n "$2" ]]; then
    # Call: "$ME help foo"
    # Rewrite to "$ME foo -h"
    #
    SUBCMD=$2
    declare -a SCMD_ARGS=( "-h" )
elif [[ 1 -eq $CALL_SCMDHELP ]]; then
    SUBCMD=$1
    declare -a SCMD_ARGS=( "-h" )
else
    # No help
    #
    # Compatibility; checklink has been replaced ny linkcheck in DAPS 3.1
    if [[ checklink = $1 ]]; then
        SUBCMD="linkcheck"
        echo "Warning: Subcommand 'checklink' is deprecated, use 'linkcheck' instead." >&2
    else
        SUBCMD=$1
    fi
    shift
    declare -a SCMD_ARGS=( "$@" )

fi
#-----------------------------------
# Check whether subcommand it is valid
#
if [[ -z ${SUBCOMMANDS[$SUBCMD]} ]]; then
    exit_on_error "Unknown subcommand \"$SUBCMD\"\nType '$ME help' to get a list of global parameters and subcommands"
fi

#-----------------------------------
# Check whether command line tries to set "forbidden" variables
#
# Now check, whether subcommand help has been requested by -h or --help
# anywhere in the argument string or if SCMD_ARGS contains bad strings
#
case "${SCMD_ARGS[@]}" in
#    "-h"|"-h "*|*" -h "*|*" -h"|"--help"|"--help "*|*" --help "*|*" --help")
#        declare -a SCMD_ARGS=( "-h" )
#        ;;
    *DOCCONF*|*DAPSROOT*|*PRJ_DIR*|*MAIN*)
        if [[ showvariable != $SUBCMD ]]; then
            exit_on_error "Please specify PRJ_DIR, DOCCONF, MAIN, or DAPSROOT via command line options"
        fi
esac

#----------------------
# Compatibility check
# User config has moved some time ago, make sure old one is not used anymore
#
if [[ -f $USER_CONFIG_OLD && ! -f $USER_CONFIG ]]; then
        exit_on_error "The DAPS user configuration file has moved from\n~/.daps/config to ~/.config/daps/dapsrc\nPlease move or delete $USER_CONFIG_OLD"
fi

# ----------------------------------------------------------------------------
# Setting up the environment with DAPSROOT
#
# In order to make developing easier, there is a hidden feature to set
# DAPSROOT, allowing to have multiple daps versions installed into
# different directories. You can switch between them by setting DAPSROOT
# accordingly. Either by command line switch --dapsroot or in  your user
# config file (DAPSROOT="<path>") or in a config file specified by --config
#
# Since command line values take precedence we need to recover them every
# time we source a file
#
# If DAPSROOT is already set, we do not need to do anything here
# If not, check whether DAPSROOT is specified in one of the configs
# otherwise use the default DAPSROOT_DEFAULT

#----------------------
# Set the config file that will get parsed:
#
# DAPS_CONFIG_FILE comes via --config
if [[ -n $DAPS_CONFIG_FILE ]]; then
    CONF_TO_PARSE="$DAPS_CONFIG_FILE"
# User Config
elif [[ -f $USER_CONFIG ]]; then
    CONF_TO_PARSE="$USER_CONFIG"
fi

#----------------------
# parse the user/specified config to get DAPSROOT
#
# only if DAPSROOT has not been specified on the command line
# _and_ a config file has been specified/exists
# Preserve command line values afterwards
#
if [[ -z "$DAPSROOT" && -s $CONF_TO_PARSE ]]; then
    parse_config "$CONF_TO_PARSE"
    # make DAPSROOT path absolute and remove trailing /
    [[ -n "$DAPSROOT" ]] && sanitize_path "$DAPSROOT" "DAPSROOT"
    recover_cmdl_values
fi

#----------------------
# Set up environment
#
# We have a custom DAPSROOT
if [[ -n "$DAPSROOT" ]]; then
    # check if valid
    if [[ ! -d "$DAPSROOT" ]]; then
        exit_on_error exit_on_error "DAPSROOT \"$2\" is not a valid directory"
    else
        # valid directory
        #  strip trailing slash
        DAPSROOT=${DAPSROOT%/}
        BIN_DIR="${DAPSROOT}/bin"
        export PATH=$BIN_DIR:$PATH
        LIB_DIR="${DAPSROOT}/lib"
        LIBEXEC_DIR="${DAPSROOT}/libexec"
        CONFIG="${DAPSROOT}/etc/config"
        XML_DEVEL_CATALOG="$XML_DEVEL_CATALOG $DAPSROOT/etc/catalog.xml"
    fi
else
    # default DAPSROOT
    # no need to set BIN_DIR here, since it should be in the default path
    #
    # if DAPSROOT_DEFAULT contains @...@ we are operating from a Git
    # checkout and no  --dapsroot was set
    #
    [[ $DAPSROOT_DEFAULT =~ @[a-zA-Z]*@ ]] && exit_on_error "You need to specify a DAPSROOT when using a Git checkout"
    DAPSROOT="$DAPSROOT_DEFAULT"
    LIB_DIR="$DEFAULT_LIB_DIR"
    LIBEXEC_DIR="$DEFAULT_LIBEXEC_DIR"
    CONFIG="$DEFAULT_CONFIG"
fi

# Path to the xslt processor wrapper script
#
XSLTPROC=${LIBEXEC_DIR}/daps-xslt

# ----------------------------------------------------------------------------
# Source functions and parse system config
#
# The environment is set up using the following hierarchy
# (1 == always wins)
#
# 1. Command line
#    - either as a real option
#    - or as variable declaration (FOO=bar) --> debugging and developing
# 2. DC-file
# 3. $USER_CONFIG (user config file)
# 4. @sysconfig@/daps/config or $DAPSROOT/etc/config
#
# Now that everything is in place, source the functions, parse the system
# config and the user config (again)

#----------------------
# Get the DAPS functions from DAPSROOT/lib
#
source "$LIB_DIR/daps_functions"

#----------------------
# Parse the system config from DAPSROOT/etc
#
parse_config "$CONFIG"

#----------------------
# Parse user config
#
if [[ -s $CONF_TO_PARSE ]]; then
    parse_config "$CONF_TO_PARSE"
    # make DAPSROOT path absolute and remove trailing / (again)
    [[ -n "$DAPSROOT" ]] && sanitize_path "$DAPSROOT" "DAPSROOT"
fi

#----------------------
# Preserve command line values
#
recover_cmdl_values


# ----------------------------------------------------------------------------
# Run early commands that do not need a DC-file or MAIN

#----------------------
# run help if requested
#
if [[ "${SCMD_ARGS[@]}" = "-h" ]]; then
    # source additional functions
    #
    [[ -f $LIB_DIR/$SUBCMD ]] && source "$LIB_DIR/$SUBCMD"
    ${SUBCOMMANDS[$SUBCMD]} "$SUBCMD" "${SCMD_ARGS[@]}"
    exit 0
fi

#----------------------
# Sample call for early commands
#
#case "$SUBCMD" in
#    foo)
#      ${SUBCOMMANDS[$SUBCMD]} "${SCMD_ARGS[@]}"
#      exit
#      ;;
#esac

#----------------------------------------------------------------------------
# Late check
# Has a DOCCONF or MAIN been specified? One of them is required

if [[ -z $DOCCONF && -z $MAIN_CMDL ]]; then
    exit_on_error "You either need to specify a DC-file or a MAIN file"
fi

#----------------------------------------------------------------------------
# Set up the environment
#
# If exist, parse DOCCONF and set up MAIN, PRJ_DIR
# otherwise try to set up PRJ_DIR from MAIN
#
# If DOCCONF has been set:
#  * DOCCONF needs to reside in PRJ_DIR
#  * DOCCONF needs to have a value for MAIN
#
# If MAIN_CMDL has been set
#  * SRC_DIR is dirname $MAIN_CMDL
#  * PRJ_DIR is assumed to be dirname $SRC_DIR
#  * If IMG_SRC_DIR is specified, ${PRJ_DIR}/$IMG_SRC_DIR needs to exist

#----------------------
# MAIN_CMDL was set
if [[ -n "$MAIN_CMDL" ]]; then
    if [[ -n "$SRC_DIR" ]]; then
        [[ "$(dirname $MAIN)" != "$SRC_DIR" ]] && echo -e "Warning: MAIN ($MAIN) and SRC_DIR ($SRC_DIR) point to different directories.\nIgnoring value provided with --srcdir."
    fi
    SRC_DIR="$(dirname $MAIN_CMDL)"
    PRJ_DIR="$(dirname $SRC_DIR)"
    SRC_FORMAT="${MAIN##*.}"
    # Validate SRC_FORMAT - needs to be xml or adoc
    [[ "adoc" = "$SRC_FORMAT" || "xml" = "$SRC_FORMAT" ]] || exit_on_error "$MAIN is an unsupported file type (.$SRC_FORMAT)\nmust be AsciiDoc (.adoc) or DocBook (.xml)"
fi

#----------------------
# DOCCONF was set
if [[ -n "$DOCCONF" ]]; then
    # DC-files need to reside in the PRJ_DIR
    # set PRJ_DIR
    PRJ_DIR="$(dirname $DOCCONF)"
    sanitize_path "$PRJ_DIR" "PRJ_DIR"
    # Parse the DC-file
    parse_config "$DOCCONF"
    # Preserve command line values
    recover_cmdl_values
    #
    # Checks
    #
    # DC-file needs at least a value for MAIN
    [[ -z "$MAIN" ]] &&  exit_on_error "Fatal: No MAIN file has been set. Please specify one via command line\nor config file"
    [[ "$MAIN" =~ ^/ ]] && exit_on_error "Fatal: MAIN was specified with an absolute path. Please use a path relative\nto the project directory ($PRJ_DIR)."
    [[ "$MAIN" =~ ^\.\./ ]] && exit_on_error "MAIN does not reside in the project directory ($PRJ_DIR), this is\nnot supported."
    if [[ -n "$SRC_DIR" ]]; then
        [[ "$SRC_DIR" =~ ^/ ]] && exit_on_error "SRC_DIR was specified with an absolute path. Please use a path relative to\nthe project directory ($PRJ_DIR)."
        [[ "$SRC_DIR" =~ ^\.\./ ]] && exit_on_error "
The SRC_DIR does not reside in the project directory ($PRJ_DIR), this is\nnot supported."
    fi
    #
    # Now set MAIN and SRC_DIR
    #
    SRC_FORMAT="${MAIN##*.}"
    # Validate SRC_FORMAT - needs to be xml or adoc
    [[ "adoc" = "$SRC_FORMAT" || "xml" = "$SRC_FORMAT" ]] || exit_on_error "$MAIN is an unsupported file type (.$SRC_FORMAT)\nmust be AsciiDoc (.adoc) or DocBook (.xml)"
    # MAIN exists
    if [[ -e "${PRJ_DIR}/$MAIN" ]]; then
        # check if SRC_DIR matches MAIN
        if [[ -n $SRC_DIR ]]; then
            [[ "$(dirname $MAIN)" != "$SRC_DIR" ]] && exit_on_error "MAIN ($MAIN) and SRC_DIR ($SRC_DIR) point to different directories.\nMAIN needs to reside in SRC_DIR."
            # MAIN and SRC_DIR are OK
            SRC_DIR="${PRJ_DIR}/$SRC_DIR"
        else
            SRC_DIR="${PRJ_DIR}/$(dirname $MAIN)"
        fi
        MAIN="${PRJ_DIR}/$MAIN"
    else
        # Do we have SRC_DIR?
        if [[ -n $SRC_DIR ]]; then
            if [[ -e "${PRJ_DIR}/${SRC_DIR}/$MAIN" ]]; then
                MAIN="${PRJ_DIR}/${SRC_DIR}/$MAIN"
                SRC_DIR="${PRJ_DIR}/${SRC_DIR}"
            else
                exit_on_error "MAIN ($MAIN) cannot be found in SRC_DIR ($SRC_DIR).\nPlease check $DOCCONF"
            fi
        # Check for defaults (xml/MAIN, adoc/MAIN)
        elif [[ -e "${PRJ_DIR}/${SRC_FORMAT}/$MAIN" ]]; then
            MAIN="${PRJ_DIR}/${SRC_FORMAT}/$MAIN"
            if [[ -n "$SRC_DIR" ]]; then
                [[ "$(dirname $MAIN)" != "$SRC_DIR" ]] && exit_on_error "MAIN ($MAIN) and SRC_DIR ($SRC_DIR) point to different directories.\nMAIN needs to reside in SRC_DIR."
            fi
            # SRC_DIR is OK
            SRC_DIR="${PRJ_DIR}/${SRC_FORMAT}"
        # no working MAIN, no SRC_DIR => error
        else
            exit_on_error "MAIN ($MAIN) does not exist or cannot be found. Either specify a path relativ\nto PRJ_DIR or set SRC_DIR in $DOCCONF"
        fi
    fi
fi

#----------------------
# Validate IMG_SRC_DIR
#

# compatibility to older DAPS versions
[[ -n "$ADOC_IMG_DIR" && -z "$IMG_SRC_DIR" ]] && IMG_SRC_DIR="$ADOC_IMG_DIR"

if [[ -n "$IMG_SRC_DIR" ]]; then
    if [[ -d "${PRJ_DIR}/$IMG_SRC_DIR" ]]; then
        IMG_SRC_DIR="${PRJ_DIR}/$IMG_SRC_DIR"
    else
        exit_on_error "Fatal: ${PRJ_DIR}/$IMG_SRC_DIR does not exist.\nThe IMG_SRC_DIR needs to be relative to $PRJ_DIR and needs to exist."
    fi
else
    if [[ -d "${PRJ_DIR}/$IMG_SRC_DIR_DEFAULT" ]]; then
        IMG_SRC_DIR="${PRJ_DIR}/$IMG_SRC_DIR_DEFAULT"
    else
        [[ $VERBOSITY -ge 2 ]] && echo "Ignoring IMG_SRC_DIR_DEFAULT ($IMG_SRC_DIR_DEFAULT) since it does not exist."
    fi
fi

#----------------------
# Set and create BUILD_DIR in case it has not been set on the command line or DC file
#
[[ -z "$BUILD_DIR" ]] && BUILD_DIR=${PRJ_DIR}/build
mkdir -p "$BUILD_DIR"

#----------------------
# Set BOOK
#
# Backwards compatability:
# In DAPS 3.1 PDFNAME was replaced by OUTPUTNAME. Use the following code
# to stay backwards compatible

[[ -n "$PDFNAME" && -z "$OUTPUTNAME" ]] && OUTPUTNAME="$PDFNAME"

if [[ -n "$OUTPUTNAME" ]]; then
    BOOK="$OUTPUTNAME"
else
    if [[ -n "$DOCCONF" ]]; then
        DC_FILE=$(basename "$DOCCONF")
        export BOOK="${DC_FILE#${CONF_PREFIX}*}"
    elif [[ -n "$MAIN_CMDL" ]]; then
        # --main was specified, BOOK is set to basenme of MAIN
        BOOK="$(basename "$MAIN" .${SRC_FORMAT})"
    fi
fi

#----------------------
# XML_CATALOG_FILES
#
# XML_MAIN_CATALOG is set via config. If it differs from the system setting for
# XML_CATALOG_FILES, add it to XML_CATALOG_FILES (in first place)
#
# Next, check if XML_DEVEL_CATALOG is set. If so, add it to XML_CATALOG_FILES
# (in first place). XML_DEVEL_CATALOG is automatically set by this script when
# working from a Git clone
#
if [[ -n "$XML_CATALOG_FILES" ]]; then
    if [[ $XML_CATALOG_FILES != $XML_MAIN_CATALOG ]]; then
        XML_CATALOG_FILES="$XML_CATALOG_FILES $XML_MAIN_CATALOG"
    fi
else
    XML_CATALOG_FILES="$XML_MAIN_CATALOG"
fi

[[ -n "$XML_USER_CATALOGS" ]] &&  XML_CATALOG_FILES="$XML_USER_CATALOGS $XML_CATALOG_FILES"
[[ -n "$XML_DEVEL_CATALOG" ]] &&  XML_CATALOG_FILES="$XML_DEVEL_CATALOG $XML_CATALOG_FILES"

#----------------------
# Result directory / LOG directory
#
RESULT_DIR="${BUILD_DIR}/${BOOK}"
LOG_DIR="${RESULT_DIR}/log"


# ----------------------------------------------------------------------------
# Check all paths from the $PATHLIST array with PRJ_DIR as base dir
#
check_pathlist "$PRJ_DIR"

# ----------------------------------------------------------------------------
# Adjust wrapper scripts if necessary
#
# FOP/XEP/ASCIIDOC CONFIG AND WRAPPER / JING WRAPPER
# when using a Git checkout, @sysconfdir@ and @pkgdatadir@ have not been
# replaced
#
# ${string/#substring/replacement}
# If $substring matches front end of $string, substitute
# $replacement for $substring.

ADOC_POST_STYLE=${ADOC_POST_STYLE/#@pkgdatadir\@/${DAPSROOT}}
ADOC_SET_STYLE=${ADOC_SET_STYLE/#@pkgdatadir\@/${DAPSROOT}}

FOP_CONFIG_FILE=${FOP_CONFIG_FILE/#@sysconfdir\@\/daps/${DAPSROOT}/etc}
FOP_WRAPPER=${FOP_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

JING_WRAPPER=${JING_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

XEP_CONFIG_FILE=${XEP_CONFIG_FILE/#@sysconfdir\@\/daps/${DAPSROOT}/etc}
XEP_WRAPPER=${XEP_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

XMLFORMAT_CONFIG_FILE=${XMLFORMAT_CONFIG_FILE/#@sysconfdir\@\/daps/${DAPSROOT}/etc}

# ----------------------------------------------------------------------------
# DocBook Stylesheet and Schema locations (from system or user config file)
# These stylesheets are used as a fallback and/or when no STYLEROOT is
# specified on the command line or the DC file
#
# check whether we have asciidoctor (supports conversion to DocBook 5).
# Set DocBook versions and backends for adoc
#
if [[ "adoc" = "$SRC_FORMAT" ]]; then
    DOCBOOK_VERSION=5
    ADOC_BACKEND=docbook5
    ASCIIDOC=$(which asciidoctor 2>/dev/null)
    if [[ 1 -eq $? ]]; then
        exit_on_error "AsciiDoctor is not installed, you cannot parse AsciiDoc sources."
    fi
else
    DOCBOOK_VERSION=$($XSLTPROC --stylesheet "${DAPSROOT}/daps-xslt/common/get-docbook-version.xsl" --file "$MAIN" "$XSLTPROCESSOR") || exit_on_error "Could not get DocBook version. Maybe $MAIN is not well-formed?"
fi

# DocBook 5
#
if [[ 5 -eq $DOCBOOK_VERSION ]]; then
    # resolve stylesheet URN
    #
    if [[ ${DOCBOOK5_STYLE_URI:0:5} = file: ]]; then
        DOCBOOK_STYLES="$DOCBOOK5_STYLE_URI"
    else
        DOCBOOK_STYLES=$(xmlcatalog "$XML_MAIN_CATALOG" \
          "$DOCBOOK5_STYLE_URI" 2>/dev/null) || \
            exit_on_error "Could not determine the DocBook stylesheet location by resolving \"$DOCBOOK5_STYLE_URI\" via xmlcatalog"
    fi
    # also get the RNG scheme location
    #

    # first check whether we come from a GIT checkout - if so
    # the URI contains @db5version@
    #
    if [[ $DOCBOOK5_RNG_URI =~ [^@]*@db5version\@.* ]]; then
        for DB5_VERSION in "5.1" "5.0"; do
            # checks 5.1 first, if it is found sets DOCBOOK5_RNG and
            # leaves loop via break, otherwise continue with 5.0
            #
            D5U="${DOCBOOK5_RNG_URI/@db5version\@/$DB5_VERSION}"
            DOCBOOK5_RNG=$(xmlcatalog "$XML_MAIN_CATALOG" "$D5U") && break
        done
    else
        if [[ ${DOCBOOK5_RNG_URI:0:5} = file: ]]; then
            DOCBOOK5_RNG="$DOCBOOK5_RNG_URI"
        else
            DOCBOOK5_RNG=$(xmlcatalog "$XML_MAIN_CATALOG" \
              "$DOCBOOK5_RNG_URI" 2>/dev/null) || \
                exit_on_error "Could not determine the DocBook 5 schema location by resolving \"$DOCBOOK5_RNG_URI\" via xmlcatalog"
        fi
    fi
    # remove file:// or file: (Debian, Tumbleweed) prefix
    #
    DOCBOOK5_RNG=${DOCBOOK5_RNG#*file:}
    DOCBOOK5_RNG=${DOCBOOK5_RNG#*//}
    #
    # check if resulting path is valid
    #
    if [[ ! -s "$DOCBOOK5_RNG" ]]; then
        if [[ -n "$DOCBOOK5_RNG_URI_CMDL" ]]; then
            exit_on_error "The URN specified with --schema points to a non-existing file \"$DOCBOOK5_RNG\""
        else
            exit_on_error "The URN specified with DOCBOOK5_RNG_URI points to a non-existing file \"$DOCBOOK5_RNG\""
        fi
    fi

# DocBook 4
#
elif [[ 4 -eq $DOCBOOK_VERSION ]]; then
    # resolve stylesheet URN
    #
    if [[ ${DOCBOOK4_STYLE_URI:0:5} = file: ]]; then
        DOCBOOK_STYLES="$DOCBOOK4_STYLE_URI"
    else
        DOCBOOK_STYLES=$(xmlcatalog "$XML_MAIN_CATALOG" \
          "$DOCBOOK4_STYLE_URI" 2>/dev/null) || \
            exit_on_error "Could not determine the DocBook stylesheet location by resolving \"$DOCBOOK4_STYLE_URI\" via xmlcatalog"
    fi
else
    exit_on_error "Fatal: Could not determine the DocBook version from $MAIN. Looks like $MAIN is not a DocBook 4/5 document."
fi

# remove the file:// or file: (Debian, Tumbleweed) string from the styles
# use ##*file:// rather than #file:// because sometimes xmlcatalog also outputs
# warnings to stdout which we would like to ignore.
# Fortunately, file:// URL is always the last string
#
DOCBOOK_STYLES=${DOCBOOK_STYLES##*file:}
DOCBOOK_STYLES=${DOCBOOK_STYLES#*//}
DOCBOOK_STYLES=${DOCBOOK_STYLES%/}

#
# Check resulting path
#
[[ -d "$DOCBOOK_STYLES" ]] || exit_on_error "DOCBOOK4_STYLE_URI or DOCBOOK5_STYLE_URI points to a non-existing directory \"$DOCBOOK_STYLES\"."

# ----------------------------------------------------------------------------
# Determine whether profiling is turned on and if so, set PROFILE_URN
#
# This needs to be done in make/common_variables.mk to allow passing
# profiling variable via command line to make:
# daps -d DC-foo profile PROFCONDITION=foobar
# PROFCONDITION=foobar is directly passed on to make and therefore is
# not known here

# ----------------------------------------------------------------------------
# Check whether we have an assembly by checking the root element from MAIN
#
IS_ASSEMBLY=$(xml sel -t -v "local-name(/*)" $MAIN 2>/dev/null)

# ----------------------------------------------------------------------------
# Now export all variables set by the config file
export "${VARLIST[@]}"

# ----------------------------------------------------------------------------
# Create a temporary file for SETFILES (setfiles.mk)
# this needs to be done here, otherwise it is impossible to
# delete the file after the script has run
#
SETFILES_TMP=$(mktemp -q --tmpdir daps_setfiles.XXXXXXXX 2>/dev/null) || exit_on_error "Could not write temporary SETFILES file."
export SETFILES_TMP

# ----------------------------------------------------------------------------
# Create XML from AsciiDoc
#
if [[ "adoc" = "$SRC_FORMAT" ]]; then
    ADOC_MAIN="$MAIN"
    ADOC_RESULT_DIR="${BUILD_DIR}/.adoc"
    ADOC_SRC_DIR="$SRC_DIR"
    MAIN="${ADOC_RESULT_DIR}/${BOOK}.xml"

    export ADOC_MAIN ADOC_RESULT_DIR ADOC_SRC_DIR MAIN
    [[ 2 -gt $VERBOSITY ]] && MOPTS="$MOPTS --silent"
    # we always want to create a fresh bigfile
    #
    make $MOPTS --always-make -f $DAPSROOT/make/adoc2xml.mk || exit_on_error "\nConverting the AsciiDoc sources to XML caused a fatal error.\nCheck the $(basename ${ASCIIDOC}) message above for details."

    # now that we have run the adoc to XML conversion SRC_DIR needs to be set
    # to the directory containing the resulting XML file
    export SRC_DIR="$ADOC_RESULT_DIR"

fi

# ----------------------------------------------------------------------------
# Create an XML bigfile from an assembly
#
if [[ "assembly" == "$IS_ASSEMBLY" ]]; then
    ASSEMBLY_MAIN="$MAIN"
    ASSEMBLY_RESULT_DIR="${BUILD_DIR}/.assembly"
    MAIN="${ASSEMBLY_RESULT_DIR}/${BOOK}.xml"

    export ASSEMBLY_MAIN ASSEMBLY_RESULT_DIR MAIN

    [[ 2 -gt $VERBOSITY ]] && MOPTS="$MOPTS --silent"
    # we always want to create a fresh bigfile
    #
    make $MOPTS --always-make -f $DAPSROOT/make/assembly2db.mk  || exit_on_error "\nConverting the assembly to DocBook caused a fatal error."
    export SRC_DIR="$ASSEMBLY_RESULT_DIR"
fi



# ----------------------------------------------------------------------------
# Check whether the document is _well-formed_ (but not whether they
# it is valid). If it is not, exit and display an error message.
# Works for both DocBook 4 and DocBook 5, as we are only checking for
# well-formedness and not for validity (a DocBook 5 validity check would
# require jing).

CHECK_WELLFORMED=$(PYTHONWARNINGS="ignore" ${LIBEXEC_DIR}/daps-xmlwellformed --xinclude ${MAIN} 2>&1)

if [[ 0 -ne $? ]]; then
    # sometimes daps-xmnlwellformed stumbles upon errors and does not produce
    # any error text (e.g. on a missing entities file)
    # Let's ignore these cases and hope for the best
    # (these errors will get caught in the validation check)
    if [[ -n "$CHECK_WELLFORMED" ]]; then
    ccecho "error" "Fatal error:\n$CHECK_WELLFORMED"
    exit 1
    fi
fi

# ----------------------------------------------------------------------------
# Finally, run the Subcommands
#

# source additional functions
#
[[ -f $LIB_DIR/$SUBCMD ]] && source "$LIB_DIR/$SUBCMD"

# By default we want to write a log file, can be overwritten by
# subcommand function
#
WRITE_LOG=1

# Quoting needs to be exactly like this, do not change
#
${SUBCOMMANDS[$SUBCMD]} "$SUBCMD" "${SCMD_ARGS[@]}"

# remove the tmp SETFILE
# done via trap, see above

exit;
