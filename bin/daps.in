#!/bin/bash
#
# Copyright (C) 2012-2016 SUSE Linux GmbH
#
# Author:
# Frank Sundermeyer <fsundermeyer at opensuse dot org>
#
# DAPS = DocBook Authoring and Publishing Suite

MY_NAME=DAPS
VERSION=@PACKAGE_VERSION@

export MY_NAME VERSION

# autoconf replaces @foo@ stuff with ${prefix}/.. if @foo@ has not
# explicitly been set, so we need to at least export prefix to
# be on the safe side

export prefix=@prefix@

#
# Do not even attempt to start, if we are in a directory that does not exist
# (fix for https://bugzilla.suse.com/show_bug.cgi?id=961526)

[[ -d $(pwd 2>/dev/null) ]] || {
    echo "Cannot operate from a directory that does not exist!"
    exit 1
    }

# ----------------------------------------------------------------------------
# VARIABLES
#
# First, list all variables we need to pass to make. They all need to be
# EXPORTED, but we do not want to write the export statement in the config
# files, so we need to have this list
#
# IMPORTANT
# All variables that need to be exported for further use in the makefiles
# need to be added here!!
#


# PENDING:
# DISTVER, PRODUCTNAME, and PRODUCTNAMEREG are only need for resolving the
# suse-PIs. Once we get rid of that, remove these variables fom the list
#

# TODO fs 2012-12-20:
# A lot of variables get exported in lib/daps_functions _and_ here - this is
# not necessary. Clean up!

declare -a VARLIST
VARLIST=(
    ASPELL_EXTRA_DICT
    ASPELL_LANG
    ASPELL_SKIP_TAGS
    BUILD_DIR
    CB_OPTIONS
    COLOR
    COMMENTS
    COMMENT_STR
    CONF_PREFIX
    CONVERT_OPTS_JPG
    CONVERT_OPTS_PNG
    CROPMARKS
    DB5TODB4
    DB5TODB4NH
    DBNOCONV
    DEBUG
    DISTVER
    DOC_DIR
    DAPSROOT
    DAPSROOT_DEFAULT
    DEF_FILE
    DESKTOPFILES
    DEVEL
    DIA_OPTIONS
    DOCCONF
    DOCCONF_DEFAULT
    DOCUMENTFILES
    DRAFT
    DRAFT_STR
    EPUB3
    EPUB_CSS
    EXPORT_DIR
    FALLBACK_STYLEROOT
    FOP_CONFIG_FILE
    FOP_CMD_OPTIONS
    FOP_JAVA_FLAGS
    FOP_JAVA_JARS
    FOP_JAVA_OPTIONS
    FOP_WRAPPER
    FORCE_REBUILD
    FORMATTER
    GRAYSCALE
    GZIP_MAN
    HTML5
    HTML_CSS
    HTMLROOT
    HTMLSINGLE
    IMAGES_COLOR
    IMAGES_GRAYSCALE
    IMG_VIEWER
    INCLUDE_MANIFEST
    INK_OPTIONS
    JING_JAVA_FLAGS
    JING_JAVA_JARS
    JING_JAVA_OPTIONS
    JING_WRAPPER
    JSP
    LIB_DIR
    LIBEXEC_DIR
    LOG_DIR
    MAIN
    META
    META_STR
    NAME
    NODC
    NOENT
    NOEPUB
    NOGZIP
    NOHTML
    NOIMG
    NOPDF
    NOSEARCH
    NOSET
    NOSTATIC
    NOREFCHECK
    NOVALID
    NOXML
    OPTIPNG
    PAGEFILES
    PARAMS
    PDFNAME
    PROFARCH
    PROFAUDIENCE
    PROFCONDITION
    PROFCONFORMANCE
    PROFILE_URN
    PROFLANG
    PROFOS
    PROFOUTPUTFORMAT
    PROFREVISION
    PROFREVISIONFLAG
    PROFROLE
    PROFSECURITY
    PROFSTATUS
    PROFUSERLEVEL
    PROFVENDOR
    PROFWORDSIZE
    REMARKS
    REMARK_STR
    RESULTCHECK
    ROOTID
    SETDATE
    SHOW
    STATIC_DIR
    STATIC_HTML
    STRINGPARAMS
    STYLEDEVEL
    STYLEROOT
    TARGET
    TXT_IGNORE_STYLEROOT
    TXT_PARAMS
    WH_SEARCH
    VALID_ROOTELEMENTS
    VERBOSITY
    XEP_CONFIG_FILE
    XEP_CMD_OPTIONS
    XEP_JAVA_FLAGS
    XEP_JAVA_JARS
    XEP_JAVA_OPTIONS
    XEP_WRAPPER
    XML_MAIN_CATALOG
    XML_USER_CATALOGS
    XSLTPARAM
    XSLTPROC
    XSLTPROCESSOR
)
# unset all for a fresh start, but preserve $DOCCONF - it might have been set
# by having sourced a DC-file

[[ -n "$DOCCONF" ]] && DOCCONF_SAVE=$DOCCONF
unset "${VARLIST[@]}"
[[ -n "$DOCCONF_SAVE" ]] && DOCCONF=$DOCCONF_SAVE


# The following UNSETLIST contains variables local to this script
# To be on the safe side, we also want to unset a few variables before we start
# because they are used/defined in make or may cause other harm if accidentally
# set
#
declare -a UNSETLIST
UNSETLIST=(
    BIN_DIR
    BUILD_DIR_CMDL
    COLOR_CMDL
    CONFIG
    DC_PATH_EXISTS
    DOC_DIR_CMDL
    DOCBOOK5_RNG_URI_CMDL
    DOCCONF_CMDL
    DOCCONF_NAME
    DAPSROOT_CMDL
    FALLBACK_STYLEROOT_CMDL
    HELP_SUBCMD
    MAIN_CMDL
    R_DIR
    STYLEROOT_CMDL
    VERBOSITY_CMDL
)
unset "${UNSETLIST[@]}"

# PATHLIST contains all variables holding a path. Relative paths need to be
# made absolute and we need this list in order to know which variables hold
# path information
#
# This list must not include FALLBACK_STYLEROOT, since we allow multiple
# values here.
# TODO: Check multiple FALLBACK_STYLEROOT paths
#
declare -a PATHLIST
PATHLIST=(
    BUILD_DIR
    DAPSROOT
    DOCCONF_DEFAULT
    EPUB_CSS
    FOP_CONFIG_FILE
    FOP_WRAPPER
    HTML_CSS
    JING_WRAPPER
    STATIC_DIR
    STYLEDEVEL
    STYLEROOT
    XEP_CONFIG_FILE
    XEP_WRAPPER
)

# ----------------------------------------------------------------------------
# We need to set some basic defaults outside of $DEFAULT_CONFIG

# this script's name
ME=$(basename "$0")

# default config file
DEFAULT_CONFIG="@sysconfdir@/daps/config"

# The default DAPSROOT
DAPSROOT_DEFAULT="@pkgdatadir@"

# default libdir
DEFAULT_LIB_DIR="${DAPSROOT_DEFAULT}/lib"
DEFAULT_LIBEXEC_DIR="${DAPSROOT_DEFAULT}/libexec"

# user config file
USER_CONFIG_OLD="$HOME/.daps/config"
USER_CONFIG="$HOME/.config/daps/dapsrc"

# if run from a terminal, set default verbosity to 1, otherwise (script, pipe)
# set it to 0

if [[ -t 1 ]]; then
    VERBOSITY=1
else
    VERBOSITY=0
fi

# Set the maximum number of concurrent jobs to the number of cores
# If egrep does not return somethiong usefule, set it to "2" as a sane default
JOBS=$(egrep -s -m1 "cpu cores\s*:" /proc/cpuinfo 2>/dev/null | sed 's/cpu cores\s*:\s*//')
[[ -z $JOBS ]] && JOBS=2

#---------------------------------------------------
# SUBCOMMANDS
#
# Associative Array
#  Key   = subcommand
#  Value = function call (from lib/daps_functions)
#
#
# The subcommands can be executed using:
#   ${SUBCOMMANDS[$SUBCMD]} $SUBCMD ${SCMD_ARGS[@]}
# Using such an array rather than a function to call the subcommands has got
# the advantage that we can very easily check whether a subcommand is valid
# or not by just testing if ${SUBCOMMANDS[$SUBCMD]} is set

declare -A SUBCOMMANDS
declare -A HELP_SUBCOMMAND

SUBCOMMANDS[bigfile]="bigfile"
HELP_SUBCOMMAND[bigfile]="Creates a single XML file (bigfile) from the MAIN-file referenced in the\nDC-file or specified on the command line by following all xi:includes.\nIf a ROOTID is specified, all xref-links pointing to locations outside the\nscope defined by the ROOTID, are replaced by text-links."

SUBCOMMANDS[checklink]="checklink"
HELP_SUBCOMMAND[checklink]="Validates ftp and http(s) links in XML sources."

SUBCOMMANDS[clean]="no_opts"
HELP_SUBCOMMAND[clean]="Removes all profiled XML sources and temporary files generated by DAPS."

SUBCOMMANDS[clean-all]="no_opts"
HELP_SUBCOMMAND[clean-all]="Removes all data (documents, images, logfiles, profiled XML, ...) generated\nby DAPS."

SUBCOMMANDS[clean-images]="no_opts"
HELP_SUBCOMMAND[clean-images]="Removes the results of all image conversions generated by DAPS."

SUBCOMMANDS[clean-package]="no_opts"
HELP_SUBCOMMAND[clean-package]="Removes all generated package data for a given DC- or MAIN-file.\nImage conversion results and profiled XML sources will not be deleted."

SUBCOMMANDS[clean-results]="no_opts"
HELP_SUBCOMMAND[clean-results]="Removes all generated documents and logfiles for a given DC- or MAIN-file.\nImage conversion results and profiled XML sources will not be deleted."

SUBCOMMANDS[dapsenv]="debugging"
HELP_SUBCOMMAND[dapsenv]="DEBUGGING: Shows a list of internal variables and their values."

SUBCOMMANDS[dist-webhelp]="build_generic"
HELP_SUBCOMMAND[dist-webhelp]="Creates a distributable tar archive of a webhelp document\n(including images and css)."

SUBCOMMANDS[dist-webhelp-name]="show_names"
HELP_SUBCOMMAND[dist-webhelp-name]="Print the file name that would result when building a distributable tar archive\nof a webhelp document."

SUBCOMMANDS[epub]="build_epub"
HELP_SUBCOMMAND[epub]="Build an eBook from the XML sources."

SUBCOMMANDS[epub-name]="show_names"
HELP_SUBCOMMAND[epub-name]="Print the file name that would result when building an eBook."

SUBCOMMANDS[getimages]="getimages"
HELP_SUBCOMMAND[getimages]="List and/or display images (in a viewer of your choice) referenced in an\nXML file or by rootid."

SUBCOMMANDS[html]="build_html_jsp"
HELP_SUBCOMMAND[html]="Build an HTML document from the XML sources."

SUBCOMMANDS[html-dir-name]="show_names"
HELP_SUBCOMMAND[html-dir-name]="Print the directory name that would result when building an HTML book."

SUBCOMMANDS[images]="build_images"
HELP_SUBCOMMAND[images]="Generate images for the given document."

SUBCOMMANDS[list-file]="filelists"
HELP_SUBCOMMAND[list-file]="Lists the filename that contains the ID specified with --rootid."

SUBCOMMANDS[list-images-missing]="filelists"
HELP_SUBCOMMAND[list-images-missing]="Prints a list of images that are referenced in the XML sources but are missing\nin the images' source directory."

SUBCOMMANDS[list-images-multisrc]="filelists"
HELP_SUBCOMMAND[list-images-multisrc]="List images for which multiple sources exist."

SUBCOMMANDS[list-srcfiles]="filelists"
HELP_SUBCOMMAND[list-srcfiles]="List all source files used to build the document specified by\nthe DC-file (XML-files, images, entity declarations, DC-file).\nUse the --no* options to exclude certain types."

SUBCOMMANDS[list-srcfiles-unused]="filelists"
HELP_SUBCOMMAND[list-srcfiles-unused]="Print a list of all source XML files from the xml directory\n and images from images/src/ _not_ used in the document referenced by the DC- or MAIN-file."

SUBCOMMANDS[locdrop]="build_locdrop"
HELP_SUBCOMMAND[locdrop]="Create all tar archives required to distribute a complete set for translation.\nRequires SVN hosting of the sources - files that need to be translated\nhave to be marked with the property doc:trans=yes."

SUBCOMMANDS[man]="build_man"
HELP_SUBCOMMAND[man]="Build one or more man pages from suitable XML sources. All <refentry> parts\nfrom the source file(s) will be transformed to man pages."

SUBCOMMANDS[man-dir-name]="show_names"
HELP_SUBCOMMAND[man-dir-name]="Print the directory name that would result when building man pages."

SUBCOMMANDS[mobi]="build_epub"
HELP_SUBCOMMAND[mobi]="Build an eBook for Amazon Kindle readers from the XML sources."

SUBCOMMANDS[mobi-name]="show_names"
HELP_SUBCOMMAND[mobi-name]="Print the file name that would result when building an Amazon Kindle book."

SUBCOMMANDS[nothing]="debugging"
HELP_SUBCOMMAND[nothing]="DEBUGGING: Benchmarking target."

SUBCOMMANDS[online-docs]="online-docs"
HELP_SUBCOMMAND[online-docs]="Creates a bigfile for the complete set, a tarball including all referenced\ngraphics in PNG format, color-pdf and epub builds as well as an archive with\na single-html build."

SUBCOMMANDS[optipng]="build_generic"
HELP_SUBCOMMAND[optipng]="Reduce the size of the source PNG images using 'optipng'.\nNOTE: This command will directly alter your source images!"

SUBCOMMANDS[package-html]="package-html"
HELP_SUBCOMMAND[package-html]="Create all archives and files needed for packaging an\nHTML document (chunked HTML, single HTML, or JSP)."

SUBCOMMANDS[package-html-dir-name]="show_names"
HELP_SUBCOMMAND[package-html-dir-name]="Print the directory name that would result when building\nan html package."

SUBCOMMANDS[package-pdf]="package-pdf"
HELP_SUBCOMMAND[package-pdf]="Create all archives and files needed for packaging a PDF document."

SUBCOMMANDS[package-pdf-dir-name]="show_names"
HELP_SUBCOMMAND[package-pdf-dir-name]="Print the directory name that would result when building\na pdf package."

SUBCOMMANDS[package-src]="package-src"
HELP_SUBCOMMAND[package-src]="creates a distributable source archive containg the profiled sources of the complete set\nincluding the original source images."

SUBCOMMANDS[package-src-name]="show_names"
HELP_SUBCOMMAND[package-src-name]="Print the file name that would result when building a distributable source\narchive."

SUBCOMMANDS[pdf]="build_pdfs"
HELP_SUBCOMMAND[pdf]="Build a PDF document from the XML sources."

SUBCOMMANDS[pdf-name]="show_names"
HELP_SUBCOMMAND[pdf-name]="Print the file name that would result when building a grayscale PDF document."

SUBCOMMANDS[productinfo]="build_generic"
HELP_SUBCOMMAND[productinfo]="Print the contents of the tags <productname> and <productnumber for the given ROOTID"

SUBCOMMANDS[profile]="build_generic"
HELP_SUBCOMMAND[profile]="Create profiled souces from the original XML sources. If the MAIN-file does\nnot contain profiling instructions, link the files into the profile directory."

SUBCOMMANDS[real-clean]="no_opts"
HELP_SUBCOMMAND[real-clean]="Removes all data (documents, images, logfiles, profiled XML, ...) generated\nby DAPS"

SUBCOMMANDS[showenv]="showenv"
HELP_SUBCOMMAND[showenv]="DEBUGGING: Target reserved for daps-docmanager"

SUBCOMMANDS[showvariable]="debugging"
HELP_SUBCOMMAND[showvariable]="DEBUGGING: Show the value of a given variable.\nUsage: showvariable VARIABLE=<VARNAME>"

SUBCOMMANDS[spellcheck]="spellcheck"
HELP_SUBCOMMAND[spellcheck]="Spellchecks the file specified with --file or the document specified by rootid."

SUBCOMMANDS[stylecheck]="stylecheck"
HELP_SUBCOMMAND[stylecheck]="Performs a style check on the given DC-file or rootid."

SUBCOMMANDS[text]="build_text"
HELP_SUBCOMMAND[text]="Build an ASCII text document the from the XML sources. Text output is\ngenerated by creating a single file HTML page parsing the result with w3m."

SUBCOMMANDS[text-name]="show_names"
HELP_SUBCOMMAND[text-name]="Print the file name that would result when building an ASCII text document."

SUBCOMMANDS[unpack-locdrop]="unpack-locdrop"
HELP_SUBCOMMAND[unpack-locdrop]="Unpack a localization drop packages source."

SUBCOMMANDS[validate]="comments_remarks"
HELP_SUBCOMMAND[validate]="Validate the profiled XML sources referenced by the DC- or MAIN-file."

SUBCOMMANDS[webhelp]="webhelp"
HELP_SUBCOMMAND[webhelp]="Build an HTML document with a table of contents/search frame (aka webhelp)\nfrom the XML sources."

SUBCOMMANDS[webhelp-dir-name]="show_names"
HELP_SUBCOMMAND[webhelp-dir-name]="Print the directory name that would result when building a webhelp document."

SUBCOMMANDS[xmlformat]="xmlformat"
HELP_SUBCOMMAND[xmlformat]="Prettify your xml-sources using the xmlformat program\nwith a configuration file supplied by daps (/etc/daps/docbook-xmlformat.conf)."

#
# deprecated targets
#

SUBCOMMANDS[all]="deprecated"
HELP_SUBCOMMAND[all]="This command is deprecated, use \"pdf\" instead."

SUBCOMMANDS[bigfile-reduced]="deprecated"
HELP_SUBCOMMAND[bigfile-reduced]="This command is no longer supported."

SUBCOMMANDS[check]="deprecated"
HELP_SUBCOMMAND[check]="This command is deprecated, use \"dapsenv\" instead."

SUBCOMMANDS[chklink]="deprecated"
HELP_SUBCOMMAND[chklink]="This command is deprecated, use \"checklink\" instead."

SUBCOMMANDS[color-pdf]="deprecated"
HELP_SUBCOMMAND[color-pdf]="This command is deprecated, use \"pdf\" instead."

SUBCOMMANDS[color-pdf-name]="deprecated"
HELP_SUBCOMMAND[color-pdf-name]="This command is deprecated, use \"pdf-name\" instead."

SUBCOMMANDS[db2novdoc]="deprecated"
HELP_SUBCOMMAND[db2novdoc]="This command is no longer supported."

SUBCOMMANDS[desktop-files]="deprecated"
HELP_SUBCOMMAND[desktop-files]="This command is deprecated, use \"package-html or package-pdf with --desktopfiles\" instead."

SUBCOMMANDS[desktop-files-dir-name]="deprecated"
HELP_SUBCOMMAND[desktop-files-dir-name]="This command is no longer supported."

SUBCOMMANDS[dist]="deprecated"
HELP_SUBCOMMAND[dist]="This command is no longer supported."

SUBCOMMANDS[dist-all]="deprecated"
HELP_SUBCOMMAND[dist-all]="This command is no longer supported."

SUBCOMMANDS[dist-book]="deprecated"
HELP_SUBCOMMAND[dist-book]="This command is no longer supported."

SUBCOMMANDS[dist-desktop-files]="deprecated"
HELP_SUBCOMMAND[dist-desktop-files]="This command is no longer supported."

SUBCOMMANDS[dist-document-files-html]="deprecated"
HELP_SUBCOMMAND[dist-document-files-html]="This command is no longer supported."

SUBCOMMANDS[dist-document-files-pdf]="deprecated"
HELP_SUBCOMMAND[dist-document-files-pdf]="This command is no longer supported."

SUBCOMMANDS[dist-graphics]="deprecated"
HELP_SUBCOMMAND[dist-graphics]="This command is deprecated, use \"package-src\" instead."

SUBCOMMANDS[dist-graphics-png]="deprecated"
HELP_SUBCOMMAND[dist-graphics-png]="This command is no longer supported."

SUBCOMMANDS[dist-html]="deprecated"
HELP_SUBCOMMAND[dist-html]="This command is deprecated, use \"package-html\" instead."

SUBCOMMANDS[dist-html-name]="deprecated"
HELP_SUBCOMMAND[dist-html-name]="This command is deprecated, use \"package-html-dir-name\" instead."

SUBCOMMANDS[dist-html-single]="deprecated"
HELP_SUBCOMMAND[dist-html-single]="This command is deprecated, use \"package-html --single\" instead."

SUBCOMMANDS[dist-htmlsingle]="deprecated"
HELP_SUBCOMMAND[dist-htmlsingle]="This command is deprecated, use \"package-html --single\" instead."

SUBCOMMANDS[dist-jsp]="deprecated"
HELP_SUBCOMMAND[dist-jsp]="=This command is deprecated, use \"package-html --jsp\" instead."

SUBCOMMANDS[dist-jsp-name]="deprecated"
HELP_SUBCOMMAND[dist-jsp-name]="This command is deprecated, use \"package-html-dir-name --jsp\" instead."

SUBCOMMANDS[dist-single-html]="deprecated"
HELP_SUBCOMMAND[dist-single-html]="This command is deprecated, use \"package-html --single\" instead."

SUBCOMMANDS[dist-single-html-name]="deprecated"
HELP_SUBCOMMAND[dist-single-html-name]="This command is deprecated, use \"package-html-dir-name --single\" instead."

SUBCOMMANDS[dist-xml]="deprecated"
HELP_SUBCOMMAND[dist-xml]="This command is deprecated, use \"package-src\" instead."

SUBCOMMANDS[dist]="deprecated"
HELP_SUBCOMMAND[dist]="This command is no longer supported."

SUBCOMMANDS[document-files-dir-name]="deprecated"
HELP_SUBCOMMAND[document-files-dir-name]="This command is no longer supported."

SUBCOMMANDS[document-files-html]="deprecated"
HELP_SUBCOMMAND[document-files-html]="This command is deprecated, use \"package-html --documentfiles\" instead."

SUBCOMMANDS[document-files-pdf]="deprecated"
HELP_SUBCOMMAND[document-files-pdf]="This command is deprecated, use \"package-pdf --documentfiles\" instead."

SUBCOMMANDS[force]="deprecated"
HELP_SUBCOMMAND[force]="This command is no longer supported."

SUBCOMMANDS[htmlsingle]="deprecated"
HELP_SUBCOMMAND[htmlsingle]="This command is deprecated, use \"html --single\" instead."

SUBCOMMANDS[htmlsingle-name]="deprecated"
HELP_SUBCOMMAND[htmlsingle-name]="This command is deprecated, use \"html-dir-name --single\" instead."

SUBCOMMANDS[html-single]="deprecated"
HELP_SUBCOMMAND[html-single]="This command is deprecated, use \"html --single\" instead."

SUBCOMMANDS[html-single-name]="deprecated"
HELP_SUBCOMMAND[html-single-name]="This command is deprecated, use \"html-dir-name --single\" instead."

SUBCOMMANDS[jana]="deprecated"
HELP_SUBCOMMAND[jana]="This command is deprecated, use \"checklink\" instead."

SUBCOMMANDS[jsp]="deprecated"
HELP_SUBCOMMAND[jsp]="This command is deprecated, use \"html --jsp\" instead."

SUBCOMMANDS[jsp-dir-name]="deprecated"
HELP_SUBCOMMAND[jsp-dir-name]="This command is deprecated, use \"html-dir-name --jsp\" instead."

SUBCOMMANDS[link-entity-dist]="deprecated"
HELP_SUBCOMMAND[link-entity-dist]="This command is no longer supported."

SUBCOMMANDS[missinggraphics]="deprecated"
HELP_SUBCOMMAND[missinggraphics]="This command is deprecated, use \"list-images-missing\" instead."

SUBCOMMANDS[online-localized]="deprecated"
HELP_SUBCOMMAND[online-localized]="\nThis command is deprecated, use \"online-docs --noset\" instead."

SUBCOMMANDS[offspring]="deprecated"
HELP_SUBCOMMAND[offspring]="This command is no longer supported."

SUBCOMMANDS[package-jsp]="deprecated"
HELP_SUBCOMMAND[package-jsp]="This command is deprecated, use \"package-html --jsp\" instead."

SUBCOMMANDS[pdf-color]="deprecated"
HELP_SUBCOMMAND[pdf-color]="This command is deprecated, use \"pdf\" instead."

SUBCOMMANDS[pdf-color-name]="deprecated"
HELP_SUBCOMMAND[pdf-color-name]="This command is deprecated, use \"pdf-name\" instead."

SUBCOMMANDS[penguin]="deprecated"
HELP_SUBCOMMAND[penguin]="This command is no longer supported."

SUBCOMMANDS[prof]="deprecated"
HELP_SUBCOMMAND[prof]="This command is deprecated, use \"profile\" instead."

SUBCOMMANDS[profiledir]="deprecated"
HELP_SUBCOMMAND[profiledir]="This command is deprecated, use \"showvariable VARIABLE=PROFILEDIR\" instead."

SUBCOMMANDS[projectfiles]="deprecated"
HELP_SUBCOMMAND[projectfiles]="This command is deprecated, use \"list-srcfiles --noimg\" instead."

SUBCOMMANDS[projectgraphics]="deprecated"
HELP_SUBCOMMAND[projectgraphics]="This command is deprecated, use \"list-srcfiles --nodc --noent --noxml\" instead."

SUBCOMMANDS[provide-images]="deprecated"
HELP_SUBCOMMAND[provide-images]="This command is deprecated, use \"images --grayscale\" instead."

SUBCOMMANDS[provide-color-images]="deprecated"
HELP_SUBCOMMAND[provide-color-images]="This command is deprecated, use \"images --color\" instead."

SUBCOMMANDS[provide-epub-images]="deprecated"
HELP_SUBCOMMAND[provide-epub-images]="This command is no longer supported."

SUBCOMMANDS[remainingfiles]="deprecated"
HELP_SUBCOMMAND[remainingfiles]="This command is deprecated, use \"list-srcfiles-unused --noimg\" instead."

SUBCOMMANDS[remaininggraphics]="deprecated"
HELP_SUBCOMMAND[remaininggraphics]="This command is deprecated, use \"list-srcfiles-unused --noxml\" instead."

SUBCOMMANDS[single-html]="deprecated"
HELP_SUBCOMMAND[single-html]="This command is deprecated, use \"html --single\" instead."

SUBCOMMANDS[single-html-dir-name]="deprecated"
HELP_SUBCOMMAND[single-html-dir-name]="This command is deprecated, use \"html-dir-name --single\" instead."

SUBCOMMANDS[txt]="deprecated"
HELP_SUBCOMMAND[txt]="This command is deprecated, use \"text\" instead."

SUBCOMMANDS[txt-name]="deprecated"
HELP_SUBCOMMAND[txt-name]="This command is deprecated, use \"text-name\" instead."

SUBCOMMANDS[warn-images]="deprecated"
HELP_SUBCOMMAND[warn-images]="Print a list of source images with non-unique names\nThis command is deprecated, use \"list-images-multisrc\" instead."

SUBCOMMANDS[wiki]="deprecated"
HELP_SUBCOMMAND[wiki]="This command is no longer supported."

SUBCOMMANDS[wiki-name]="deprecated"
HELP_SUBCOMMAND[wiki-name]="This command is no longer supported."

SUBCOMMANDS[xmlfiles]="deprecated"
HELP_SUBCOMMAND[xmlfiles]="This command is deprecated, use \"list-srcfiles --nodc --noent --noimg\" instead."

SUBCOMMANDS[xmlgraphics-bw]="deprecated"
HELP_SUBCOMMAND[xmlgraphics-bw]="This command is no longer supported."

SUBCOMMANDS[xmlgraphics]="deprecated"
HELP_SUBCOMMAND[xmlgraphics]="This command is no longer supported."

# ----------------------------------------------------------------------------
# FUNCTIONS
#
# We need to declare a few basic funtions first because they are needed
# immediately. All other functions can be found at
# $DAPSROOT/lib/daps-functions
# ---------
# Help
#

function daps_help {
    cat <<EOF_helptext
Usage:
  1. $ME -d DC-file [--options] <subcommand> [--subcommand-options]
  2. $ME -m MAIN file [--options] <subcommand> [--subcommand-options]


Global Options:
  --builddir=BUILD_DIR      Directory where every output $ME generates will end
                            up
                            Default: <doc dir>/build/$BOOK
  --color=(0|1)             By default errors, results, warnings and certain
                            info messages are printed in color using bash color
                            codes. Set to '0' to turn off colors.
                            Default: 1 (when the output does not go to a
                                        terminal, colored output will be
                                        disabled automatically)
  --commands                Show a list of available DAPS sub commands
  --debug                   Print debugging messages. Alternatively see the
                            --verbose options for an output that is better
                            readable.
  --docconfig=DC-file,
  -d DC-file                Path to doc config file to use. Mandatory
                            unless there is only a single DC-file in the current
                            directory or unless you have configured a default
                            value (DOCCONF_DEFAULT) in $USER_CONFIG.
                            Note: Options --docconfig and --main exclude
                                  each other.
  --fb_styleroot            Fallback styleroot directories. Can only be used in
                            conjunction with --styleroot. By default, the
                            DocBook stylesheets are used as a fallback if
                            custom styles for an output format are not present.
                            With this option you can specify a list of
                            alternative fallbacks (space separated absolute
                            paths). The directories will be tested in the order
                            specified, the first one that applies to the
                            requested format, will be used.  The original
                            DocBook stylesheets will be used as a last resort.
                            Useful if you have forks of your custom
                            stylesheets.
  --force                   Force a rebuild of the document even when an
                            up-to-date version exists.
  --help, -h                Help
  --jobs                    Specify how many parallel jobs to use. Higher
                            numbers will significantly increase the processing
                            speed, but will also set your machine under heavy
                            load, up to a point where it may become
                            (temporarily) unresponsive.
                            Default: Use as man jobs as available CPU cores.
  --main, -m                Path to the main file defining your document.
                            Note: Options --main and --docconfig exclude
                                  each other.
  --schema                  URN to a DocBook 5 schema that is to be used for
                            validation. Will be ignored when validating
                            DocBook 4 documents.
                            Note: To validate with a local schema, specify an
                                  absolute path with a "file://" prefix
                                  (e.g. "file:///foo/schema.rnc").
  --styleroot               By default, daps uses the DocBook Stylesheets to
                            create output. If you have your own set of
                            stylesheets, specify the absolute path to the
                            stylesheet directory here. The DocBook stylesheets
                            will be used as a fallback in case styles are not
                            defined for all output formats.
  --verbosity=0, -v0        Verbosity Level 0 (print 1 line of results)
  --verbosity=1, -v1, -v    Verbosity Level 1 (print intermediate results)
  --verbosity=2, -v2, -vv   Verbosity Level 2 (print all files created)
  --verbosity=3, -v3, -vvv  Verbosity Level 3 (print all commands, very verbose)

  --version                 Print version number

  --xsltprocessor=PROCESSOR Specify an xslt processor that is used to transorm
                            the XML files. Currently supported are \"xsltproc\"
                            and \"saxon\" (version 6).
                            Default: xsltproc

Subcommands:
   help                       Print this help.

  Generate Books:
    epub                      ePUB book
    html                      HTML book (chunked or single file HTML, jsp)
    man                       man pages
    mobi                      Amazon Kindle eBook
    pdf                       PDF book (color, grayscale, printable)
    text                      ASCII book
    webhelp                   HTML book with collapsable TOC and search


  File lists:
    list-file                 Lists the filename that contains the ID specified
                              with the mandatory parameter --rootid.
    list-srcfiles             List source files (XML sources, images, entity
                              declarations, DC-file) used by the document
                              reference by the DC-file.
    list-srcfiles-unused      List files from the xml/ and images/src/
                              directories not used by the document reference
                              by the DC-file.
    list-images-missing       List images referenced in the XML sources but
                              missing in the images' source directory.
    list-images-multisrc      List images for which mutiple sources exist
                              (e.g. foo.svg and foo.png).

  Cleaning up:
    clean                     Remove all profiled sources and temporary files.
    clean-images              Remove all generated images.
    clean-package             Remove all generated package data for the given
                              DC-file. Generated images and profiled sources
                              will _not_ be deleted.
    clean-results             Remove all generated books, archives, and log
                              files for the given DC-file. Generated images
                              and profiled sources will _not_ be deleted.
    clean-all, real-clean     Remove everything generated by $ME.

  Packaging:
    package-html              Provide an HTML tarball (chunked HTML,
                              single HTML, or JSP), desktop, document,
                              and/or page files (for KDE and GNOME).
    package-pdf               Provide a PDF, desktop, document, and/or
                              page files (for KDE and GNOME).
    package-src               Provide profiled XML sources and graphics

  Deploying:
    locdrop                   Provide everything that is needed to translate a
                              set.
    online-docs               Provide a profiled XML bigfile, a graphics
                              tarball (PNG only), color-pdf, epub, and
                              a single-html archive.
    unpack-locdrop            Unpack a localization drop packages source.

  Other Commands:
    checklink                 Linkchecker for links from <ulink> tags
    getimages                 List or display images from a profiled DocBook
                              XML file.
    optipng                   Optimize (size) source PNGs.
    profile                   Profile XML sources.
    spellcheck                Spellchecks the file specified with --file or the
                              document specified by rootid.
    stylecheck                Performs a style check on the given DC-file or
                              rootid.
    validate                  Validate profiled sources. Automatically profiles
                              the XML sources if needed.
    xmlformat                 Prettify the XNL source files using
                              daps-xmlformat.

  File and Directory Names:
    <target>-name             Print resulting file name for <target>. <target>
                              may be one of color-pdf, epub, html-single,
                              pdf, txt.
    <target>-dir-name         Print resulting directory name for <target>.
                              <target> may be html, man or webhelp.

  Debugging:
    bigfile                   Creates a single "big" XML file by resolving
                              xi:includes. Useful for detecting validation
                              errors that cannot be found otherwise.
    dapsenv                   Print a list of the most important make variables
                              and their value.
    images                    Generates all images for the given DC-file or
                              rootid.
    showvariable              Print value of a given make variable:
                              $ME showvariable VARIABLE=<MAKE_VARIABLE>.

Type '$ME <subcommand> -h' for help on a specific subcommand.
EOF_helptext
}

function daps_commands {
    # show a list of available subcommands from the SUBCOMMANDS array
    # ignore the commands set to deprecated
    local VAL

    for VAL in "${SUBCOMMANDS[@]}"; do
        if [[ -n "${VAL##*=deprecated}" ]]; then
            echo "${VAL%%=*}"
        fi
    done | sort
}


# ---------
# Clean up
#
function clean_daps {
    [[ -f $SETFILES_TMP ]] && rm -f "$SETFILES_TMP"
}

# ---------
# Verbose error handling
#
function exit_on_error {
    echo -e "ERROR: ${1}" >&2
    clean_daps
    exit 1;
}

# ---------
# Get absolute path, remove trailing / and test if path is valid
#
function sanitize_path {
    # Takes values
    # $1 = path
    # $2 = variable name holding $1
    # $3 = additional base dir for $1 (optional)
    #
    # sets absolute path without trailing / for $1, links are being followed
    # also tests if paths are valid
    #
    # in case of a non-existing path, returns 2 if variablename matches
    # _WRAPPER, else returns 1
    #
    local ABSPATH BASEDIR MYPATH VARNAME

    MYPATH=$1
    VARNAME=$2
    [[ -n "$3" ]] && BASEDIR=$3

    # Do nothing if $1 is an empty value
    [[ -z "$MYPATH" ]] && return

    # Remove preceding file:// scheme
    if [[ ${MYPATH:0:5} = file: ]]; then
        MYPATH=${MYPATH#file:}
    fi

    # ignore values that need to be set by configure
    # (makes it possible to directly use a SVN checkout)
    [[ $MYPATH =~ @[a-zA-Z]*@ ]] && return

    # 1. Remove trailing Slash
    #
    MYPATH=${MYPATH%/} # remove trailing slash

    if [[ $MYPATH =~ ^~.* ]]; then
        # 2. Replace ~/ with $HOME
        if [[ $MYPATH =~ ^~/.* ]]; then
            MYPATH=${MYPATH/#\~\//$HOME/}
        else
            # 3. Replace ~USER with a real path
            # the %q option to printf quotes and escapes dangerous characters
            # see http://stackoverflow.com/questions/2069467/have-to-determine-all-users-home-directories-tilde-scripting-problem
            eval MYPATH="$(printf "%q" "$MYPATH")"
        fi
    fi

    if [[ "/" != ${MYPATH:0:1} ]]; then
        [[ -n "$BASEDIR" ]] && MYPATH="${BASEDIR}/${MYPATH}"
        ABSPATH=$(readlink -en "$MYPATH")
        if [[ 0 = "$?" ]]; then
            declare -g $VARNAME="$ABSPATH"
        else
            exit_on_error "$VARNAME=$MYPATH: Path does not exist"
        fi
    else
        # path is already absolute, set to MYPATH (because of having cut
        # the trailing /
        if [[ -d $MYPATH || -f $MYPATH ]]; then
            declare -g $VARNAME="$MYPATH"
        else
            exit_on_error "$VARNAME=$MYPATH: Path does not exist"
        fi
    fi
}

# ----------------------
# Check all paths in $PATHLIST with sanitize_path
#
function check_pathlist {
    local BASEDIR DIR VAL

    BASEDIR=$1

    for DIR in "${PATHLIST[@]}"; do
        eval "VAL=\$$DIR"
        if [[ -n "$VAL" ]]; then
            sanitize_path "$VAL" "$DIR" "$BASEDIR"
        fi
    done
}

# ---------
# Try to automatically get the DOCCONF
#
function autoset_docconf {
    # if there is only one DOCCONF file in the current directory, use it
    # and also set DOC_DIR
    #
    local DC_FILENAME DC_PARENT DC_REAL_PATH DC_REAL_DIR
    declare -a DC_COUNT
    DC_COUNT=( $(find -L . -maxdepth 1 -name "${CONF_PREFIX}*" -type f) )
    if [[ 1 = "${#DC_COUNT[@]}" ]]; then
        # There is only one DOCCONF file
        #
        # two possibilites:
        # 1. We are already in DOC_DIR
        # 2. We are in the documents build result directory
        # (DOC_DIR/build/<name>), where daps creates a link to the
        # real ENV file
        if [[ -h ${DC_COUNT[0]} ]]; then
            # DOCCONF is a link
            DC_REAL_PATH=$(readlink -nm "${DC_COUNT[0]}")
            if [[ 0 = "$?" ]]; then
            declare -g $VARNAME="$ABSPATH"
        else
            exit_on_error "$VARNAME=$MYPATH: Path does not exist"
        fi
            DC_REAL_DIR=$(dirname "$DC_REAL_PATH")
            DC_FILENAME=$(basename "$DC_REAL_PATH")
            DC_PARENT=${DC_FILENAME#${CONF_PREFIX}*}
            if [[ -e ${DC_REAL_DIR}/build/${DC_PARENT}/$DC_FILENAME ]]; then
                # we are in the result dir - set DOCCONF to the
                # real path (with links "resolved")
                DOCCONF_CMDL="$DC_REAL_PATH"
            else
                # we are in DOC_DIR
                # preserve links
                DOCCONF_CMDL="${PWD}/${DC_COUNT[0]}"
            fi
        else
            # no link, we are in DOC_DIR
            sanitize_path "${DC_COUNT[0]}" "DOCCONF_CMDL"
        fi
        # set DOC_DIR
        DOC_DIR=$(dirname "$DOCCONF_CMDL")
        if [[ 2 -le $VERBOSITY ]]; then
            echo "Using automatically detected DOCCONF $DOCCONF_CMDL"
        fi
    else
        # more than one or no DOCCONF
        exit_on_error "Could not find a valid MAIN file.\nPlease specify either a DOCCONF or a MAIN file at the command line"
    fi
}

# ---------
# Set MAIN to an absolute path
#

function set_mainfile {
    local MAINFILE
    MAINFILE="$1"
    if [[ -e "$MAINFILE" ]]; then
        # MAINFILE is a file or link
        sanitize_path "$MAINFILE" "MAIN_CMDL"
        if [[ -z "$DOC_DIR" ]]; then
            DOC_DIR=$(dirname "$MAIN_CMDL")
            DOC_DIR=${DOC_DIR%/xml*} #remove xml directory
        fi
        [[ -e ${DOC_DIR}/xml/$(basename "$MAIN_CMDL") ]] || exit_on_error "XML files must reside in an \"xml/\" directory. \"$MAIN_CMDL\" is not a valid location."
    else
        if [[ -e "xml/$MAINFILE" ]]; then
            # MAIN is not a valid file, but ./xml/$MAIN exists
            sanitize_path "xml/$MAINFILE" "MAIN_CMDL"
            if [[ -z "$DOC_DIR" ]]; then
                DOC_DIR="$PWD"
            fi
            if [[ 2 -le $VERBOSITY ]]; then
                echo "Using MAIN file $MAIN_CMDL"
            fi
        else
            if [[ -n "$DOC_DIR" ]]; then
                MAIN_CMDL="${DOC_DIR}/xml/$(basename "$MAINFILE")"
                [[ -e $MAIN_CMDL ]] || exit_on_error "XML files must reside in an \"xml/\" directory. \"$MAIN_CMDL\" is not a valid location."
            else
                exit_on_error "Fatal error: ${PWD}/$MAINFILE does not exist."
            fi
        fi
    fi
}


# ---------
# Recover command-line values
#
function recover_cmdl_values {
    test -n "$BUILD_DIR_CMDL" && BUILD_DIR="$BUILD_DIR_CMDL"
    test -n "$COLOR_CMDL"     && COLOR="$COLOR_CMDL"
    test -n "$DOCBOOK5_RNG_URI_CMDL" && DOCBOOK5_RNG_URI="$DOCBOOK5_RNG_URI_CMDL"
    test -n "$DOCCONF_CMDL"   && DOCCONF="$DOCCONF_CMDL"
    test -n "$DAPSROOT_CMDL"  && DAPSROOT="$DAPSROOT_CMDL"
    test -n "$FALLBACK_STYLEROOT_CMDL" && FALLBACK_STYLEROOT="$FALLBACK_STYLEROOT_CMDL"
    test -n "$MAIN_CMDL"      && MAIN="$MAIN_CMDL"
    test -n "$STYLEROOT_CMDL" && STYLEROOT="$STYLEROOT_CMDL"
    test -n "$VERBOSITY_CMDL" && VERBOSITY="$VERBOSITY_CMDL"
    test -n "$XSLTPROCESSOR_CMDL" && XSLTPROCESSOR="$XSLTPROCESSOR_CMDL"
}

# ---------
# Config file parser for DC-files and general configs
# More secure than just sourcing the config files
#

function parse_config {

    # Inspired by
    # https://stackoverflow.com/questions/16571739/bash-parsing-variables-from-config-file
    # Takes the config file to parse as required value
    #
    [[ -z $1 ]] && exit_on_error "Function parse_config must be called with a config file as an argument"

    local KEY LINE_NO OLD_IFS TMP_VALUE VALUE

    LINE_NO=0
    OLD_IFS="$IFS"
    while IFS='= ' read KEY VALUE; do
       let LINE_NO++
       if [[ ! "$KEY" =~ ^\ *# && -n "$KEY" ]]; then
           VALUE="${VALUE%"${VALUE##*[^ ]}"}" # Del trailing spaces
           VALUE="${VALUE#[\"\']*}"               # Del opening string quotes
           TMP_VALUE="${VALUE%[\"\']*}"           # Del closing string quotes
           #
           # If value was quoted, we now have removed everything that was
           # added after the last quote, incl. trailing comments. Therefore
           # we are ready parsing quoted strings right here - we have removed
           # the quotes and want to keep everything that has been between the
           # quotes (and that includes # )
           # However, if the string was not quoted, trailing comments have not
           # been removed yet. And since we want to remove everything that
           # comes after the first #, we need to use the greedy operator
           # ${VALUE%%\#*}. If we would use that on the quoted strings,
           # everything after a potential # would be deleted "foo#bar" => foo.
           # Therefore we only remove comments on unquoted strings. If a
           # string was unquoted TMP_VALUE and VALUE will be identical
           # here:

           if [[ "$TMP_VALUE" = "$VALUE" ]]; then
               VALUE="${TMP_VALUE%%\#*}" # Del inline right comments
           else
               VALUE="$TMP_VALUE"
           fi
           declare -g $KEY="$VALUE" || exit_on_error "Invalid value in config file $1 in line $LINE_NO"
       fi
    done < "$1"
    IFS="$OLD_IFS"
}



trap "exit_on_error '\nCaught SIGTERM/SIGINT'" SIGTERM SIGINT
trap "clean_daps" ERR EXIT

# ----------------------------------------------------------------------------
# Parsing the command line arguments with GNU getopt
#
# In order to separate general daps parameters from subcommand parameters,
# we are setting POSIXLY_CORRECT before parsing the first time.
# This causes getopt to interprete all remaining parameters as non-option
# parameters as soon as the first non-option parameter (the subcommand) is
# found. This value must be _exported_

export POSIXLY_CORRECT=1

# So, the first getopt go will parse all parameters listed directly after the
# daps command, leaving an array ($@) with the subcommand and it's
# parameters, which can be parsed in a second getopt go.

#-------------------------------
# Parsing the daps parameters
#
# If variables such as $BUILD_DIR, $DOCCONF, and $DAPSROOT are set via command
# line switch, we do not want to overwrite them by any other file we source
# at a later stage (command line always wins).
# Declaring the variables as readonly is unfortunately not an option, since
# every attempt to (un)set a read-only variable throws an error - something
# we do not want when sourcing a config-file.
# Therefore we need to save each variable twice in order to recover the
# original value.

ARGS=$(getopt -o d:e:hm:v:: -l builddir:,color:,colour:,commands,debug,docconfig:,dapsroot:,envfile:,fb_styleroot:,force,help,jobs:,main:,schema:,styleroot:,verbosity::,version,xsltprocessor: -n "$ME" -- "$@")

# Exit when getopt returns errors
#
GETOPT_RETURN_CODE=$?
[[ 0 != $GETOPT_RETURN_CODE ]] && exit $GETOPT_RETURN_CODE

eval set -- "$ARGS"

while true ; do
    case "$1" in
        --builddir)
            [[ -d $2 ]] || exit_on_error "BUILD_DIR \"$2\" is not a valid directory"
            [[ -w $2 ]] || exit_on_error "BUILD_DIR \"$2\" is not writeable"
            # make path absolute and strip trailing slash
            sanitize_path "$2" "BUILD_DIR_CMDL"
            BUILD_DIR="$BUILD_DIR_CMDL"
            shift 2
            ;;
        --color|--colour)
            if [[ 1 != $2 && 0 != $2 ]]; then
                exit_on_error "Wrong value ($2) for COLOR. Must be \"0\" or \"1\""
            fi
            COLOR_CMDL=$2
            export COLOR="$COLOR_CMDL"
            shift 2
            ;;
        --commands)
            daps_commands
            exit 0
            ;;
        -d|--docconfig|-e|--envfile)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "DOCCONF_CMDL"
            DOCCONF="$DOCCONF_CMDL"
            shift 2
            ;;
        --dapsroot)
            [[ -d $2 ]] || exit_on_error "DAPSROOT \"$2\" is not a valid directory"
            # make path absolute and strip trailing slash
            sanitize_path "$2" "DAPSROOT_CMDL"
            DAPSROOT="$DAPSROOT_CMDL"
#           DEVEL=1
            shift 2
            ;;
        --debug)
            # debug also implies VERBOSITY=2
            DEBUG=1
            VERBOSITY_CMDL=2
            VERBOSITY=$VERBOSITY_CMDL
            # enable JAVA debug messages (fop, xep, jing)
            export VERBOSE=1
            shift
            ;;
        --fb_styleroot)
            # We are allowing multiple values, space-seperated
            for FBS in $2; do
                # make path absolute and strip trailing slash
                sanitize_path "$FBS" "FBS_LIST"
                FALLBACK_STYLEROOT_CMDL="$FALLBACK_STYLEROOT_CMDL $FBS_LIST"
            done
            FALLBACK_STYLEROOT="$FALLBACK_STYLEROOT_CMDL"
            shift 2
            ;;
        --force)
            FORCE_REBUILD=1
            shift
            ;;
        -h|--help)
            # if it's just "-h/--help", then print the global daps help
            # if "-h/--help" is followed by a subcommand, then set a marker
            # to call the subcommand's help
            shift;
            if [[ "" = "$2" ]]; then
                daps_help
                exit 0;
            else
                CALL_SCMDHELP=1
            fi
            ;;
        --jobs)
            if [[ $2 =~ ^[0-9][0-9]*$ ]]; then
                JOBS="$2"
            else
                exit_on_error "Wrong value ($2) for --jobs. Must be a numeric"
            fi
            shift 2
            ;;
        -m|--main)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "MAIN_CMDL"
            MAIN="$MAIN_CMDL"
            shift 2
            ;;
        --schema)
            DOCBOOK5_RNG_URI="$2"
            DOCBOOK5_RNG_URI_CMDL="$DOCBOOK5_RNG_URI"
            shift 2
            ;;
        --styleroot)
            # make path absolute and strip trailing slash
            sanitize_path "$2" "STYLEROOT_CMDL"
            STYLEROOT="$STYLEROOT_CMDL"
            shift 2
            ;;
        -v|--verbosity)
            # $VERBOSITY will be parsed in the makefiles
            # VERBOSITY=0: print only final results message (default)
            # VERBOSITY=1: results of each target that is called
            # VERBOSITY=2: detailed output of each target
            #
            if [[ 1 = "$DEBUG" ]]; then
                VERBOSITY_CMDL=2
            else
                if [[ 0 = "$2" ]]; then
                    VERBOSITY_CMDL=0
                elif [[ 1 = "$2" || "" = "$2" ]]; then
                    VERBOSITY_CMDL=1
                elif [[ 2 = "$2" || "v" = "$2" ]]; then
                    VERBOSITY_CMDL=2
                else
                    VERBOSITY_CMDL=3
                fi
            fi
            VERBOSITY="$VERBOSITY_CMDL"
            shift 2
            ;;
        --version)
            echo "$ME $VERSION"
            exit 0
            ;;
        --xsltprocessor)
            which "$2" >/dev/null 2>&1 || exit_on_error "Cannot find the XSLT processor \"$2\"."
            XSLTPROCESSOR_CMDL="$2"
            XSLTPROCESSOR="$XSLTPROCESSOR_CMDL"
            shift 2
            ;;
        --) shift ; break ;;
        *) exit_on_error "Internal error!" ;;
    esac
done

# You can only specify DOCCONF or MAIN, not both
#
if [[ -n "$DOCCONF_CMDL" && -n "$MAIN_CMDL" ]]; then
    exit_on_error "The options -d/--docconfig and --main exclude each other."
fi

# Check FALLBACK_STYLEROOT and STYLEROOT
#
if [[ -n "$FALLBACK_STYLEROOT" && -z "$STYLEROOT" ]]; then
    if [[ 0 != $VERBOSITY ]]; then
        echo "Warning: --styleroot is not specified, ignoring --fb_styleroot" >&2
    fi
fi

unset POSIXLY_CORRECT # we want the regular getopts behaviour on the second run

#-----------------------------------
# Store the subcommand and it's args

# extract the subcommand from $@ if $ME has been called with no arguments
# or with "help" as the only argument, run global help. If it was called with
# SUBCOMMAND help or help SUBCOMMAND, rewrite the command so the subcommand help
# is displayed.

if [[ -z "$1" ]] || [[ help = "$1" && -z "$2" ]]; then
    # Call: "$ME" or "$ME help"
    #
    daps_help
    exit 0
elif [[ help = "$2" ]]; then
    # Call: "$ME foo help ..."
    # Rewrite to "$ME foo -h"
    #
    SUBCMD=$1
    declare -a SCMD_ARGS=( "-h" )
elif [[ help = "$1" && -n "$2" ]]; then
    # Call: "$ME help foo"
    # Rewrite to "$ME foo -h"
    #
    SUBCMD=$2
    declare -a SCMD_ARGS=( "-h" )
elif [[ 1 = "$CALL_SCMDHELP" ]]; then
    SUBCMD=$1
    declare -a SCMD_ARGS=( "-h" )
else
    # No help
    SUBCMD=$1
    shift
    declare -a SCMD_ARGS=( "$@" )
fi

# Now that we have the subcommand, check whether it is valid
#
if [[ -z ${SUBCOMMANDS[$SUBCMD]} ]]; then
    exit_on_error "Error: Unknown subcommand \"$SUBCMD\"\nType '$ME help' to get a list of global parameters and subcommands"
fi

# Now check, whether subcommand help has been requested by -h or --help
# anywhere in the argument string or if SCMD_ARGS contains bad strings
#
case "${SCMD_ARGS[@]}" in
    "-h"|"-h "*|*" -h "*|*" -h"|"--help"|"--help "*|*" --help "*|*" --help")
        declare -a SCMD_ARGS=( "-h" )
        ;;
    *DOCCONF*|*DAPSROOT*|*DOC_DIR*|*MAIN*)
        if [[ showvariable != $SUBCMD ]]; then
            exit_on_error "Please specify DOC_DIR, DOCCONF, MAIN, or DAPSROOT via command line options"
        fi
esac


# ----------------------------------------------------------------------------
# Setting up the environment for the complete mechanics
#
# The environment is set up using the following hierachy
# (1 == always wins)
#
# 1. Command line
#    - either as a real option
#    - or as variable declaration (FOO=bar) --> debugging and developing
# 2. DC-file
# 3. $USER_CONFIG (user config file)
# 4. @sysconfig@/daps/config or $DAPSROOT/etc/config
#
# In order to make developing easier, there is a hidden feature to set
# DAPSROOT, allowing to have multiple daps versions installed into
# different directories. You can switch between them by setting DAPSROOT
# accordingly. Either by command line switch --dtdroot or in  your user
# config file (DAPSROOT="<path>")
#
# Since commandline values take precedence we need to recover them every
# time we source a file
#

# source the user config for the first time to get DAPSROOT
#

############# INTERLUDE: Copy/Move USER_CONFIG_OLD #####################
#
# Move/copy an old DAPS config directory to ~/.config if not already existing
#
MOVE_CONFIG=""
if [[ -f $USER_CONFIG_OLD && ! -f $USER_CONFIG ]]; then
    ccecho "warn" "The DAPS user configuration file has moved from\n~/.daps/config to ~/.config/daps/dapsrc"
    NEW_CONFDIR=$(dirname "$USER_CONFIG")
    NEW_CONFFILE=$(basename "$USER_CONFIG")
    OLD_CONFDIR=$(dirname "$USER_CONFIG_OLD")
    OLD_CONFFILE=$(basename "$USER_CONFIG_OLD")
    while [[ ! $MOVE_CONFIG =~ ^[CcMmNn]$ ]] ; do
        read -e -t 20 -i n -p "Do you want me to [c]opy it/[m]ove it/do [n]othing? " MOVE_CONFIG
        [[ $? -gt 128 ]] && MOVE_CONFIG="n" # timeout reached
    done
    case "$MOVE_CONFIG" in
        C|c)
            cp -r "$OLD_CONFDIR" "$NEW_CONFDIR" && mv "${NEW_CONFDIR}/$OLD_CONFFILE" "${NEW_CONFDIR}/$NEW_CONFFILE"
            if [[ 0 -eq $? ]]; then
                ccecho "info" "The DAPS config directory $OLD_CONFDIR has been copied to $NEW_CONFDIR.\nThe DAPS config file has been renamed to $NEW_CONFFILE."
            else
                ccecho "warn" "Copying the DAPS config directory failed"
            fi
            ;;
        M|m)
            mv "$OLD_CONFDIR" "$NEW_CONFDIR" && mv "${NEW_CONFDIR}/$OLD_CONFFILE" "${NEW_CONFDIR}/$NEW_CONFFILE"
            if [[ 0 -eq $? ]]; then
                ccecho "info" "The DAPS config directory $OLD_CONFDIR has been moved to $NEW_CONFDIR.\nThe DAPS config file has been renamed to $NEW_CONFFILE."
            else
                ccecho "warn" "Moving the DAPS config file failed"
            fi
            ;;
        *)
            ccecho "info" "\nThe DAPS config has not been touched and will not be used in this DAPS run"
            ;;
    esac
fi


if [[ -f $USER_CONFIG && -z "$DAPSROOT_CMDL" ]]; then
    parse_config "$USER_CONFIG"
    # make DAPSROOT path absolute and remove trailing /
    [[ -n "$DAPSROOT" ]] && sanitize_path "$DAPSROOT" "DAPSROOT" \
        "$(readlink -en "$(dirname "$USER_CONFIG")")"
    recover_cmdl_values
fi

# IF we have a custom DAPSROOT, $DAPSROOT is set by now - if not, use the default
if [[ -n "$DAPSROOT" ]]; then
    # custom DAPSROOT was set
    if [[ ! -d "$DAPSROOT" ]]; then
        exit_on_error exit_on_error "DAPSROOT \"$2\" is not a valid directory"
    else
        # valid directory
        #  strip trailing slash
        DAPSROOT=${DAPSROOT%/}
        BIN_DIR="${DAPSROOT}/bin"
        export PATH=$BIN_DIR:$PATH
        LIB_DIR="${DAPSROOT}/lib"
        LIBEXEC_DIR="${DAPSROOT}/libexec"
        CONFIG="${DAPSROOT}/etc/config"
        XML_DEVEL_CATALOG="$XML_DEVEL_CATALOG $DAPSROOT/etc/catalog.xml"
#        XML_CATALOG_FILES="$XML_DEVEL_CATALOG $XML_CATALOG_FILES"
    fi
else
    # default DAPSROOT
    # no need to set BIN_DIR here, since it should be in the default path
    #
    # if DAPSROOT_DEFAULT contains @...@ we are operating from an SVN
    # checkout and no  --dapsroot was set
    #
    [[ $DAPSROOT_DEFAULT =~ @[a-zA-Z]*@ ]] && exit_on_error "You need to specify a DAPSROOT when using an SVN checkout"
    DAPSROOT="$DAPSROOT_DEFAULT"
    LIB_DIR="$DEFAULT_LIB_DIR"
    LIBEXEC_DIR="$DEFAULT_LIBEXEC_DIR"
    CONFIG="$DEFAULT_CONFIG"
fi

# Path to the xslt processor wrapper script
#
XSLTPROC=${DAPSROOT}/libexec/daps-xslt


# ---------------------------------------------
# Source functions and parse system config
#
# Now that everything is in place, source the functions, parse the system
# config and the user config (again)
source "$LIB_DIR/daps_functions"
parse_config "$CONFIG"

# Parse user config
#
if [[ -f $USER_CONFIG ]]; then
    parse_config "$USER_CONFIG"
    # make paths from PATHLIST absolute and remove trailing /
#    MY_BASEDIR=$(readlink -en $(dirname $USER_CONFIG))
#    check_pathlist "$MY_BASEDIR"
    # make DAPSROOT path absolute and remove trailing /
    [[ -n "$DAPSROOT" ]] && sanitize_path "$DAPSROOT" "DAPSROOT" \
        "$(readlink -en "$(dirname "$USER_CONFIG")")"
fi
recover_cmdl_values

#----------------------------------
# Run early commands that do not need to have an environment fully set up

#
# run help if requested
#
if [[ "${SCMD_ARGS[@]}" = "-h" ]]; then
    ${SUBCOMMANDS[$SUBCMD]} "$SUBCMD" "${SCMD_ARGS[@]}"
fi

# Sample call for early commands
#
#case "$SUBCMD" in
#    foo)
#      ${SUBCOMMANDS[$SUBCMD]} "${SCMD_ARGS[@]}"
#      exit
#      ;;
#esac

#-------------------------------------
# Parse DOCCONF and set up MAIN, DOC_DIR
#
# The black magic part of daps ... ;-)
#
# Three possibilities:
# 1. MAIN was set on the command line or via user config
# 2. DOCCONF was set on the command line
# 3. MAIN and DOCCONF were _not_ set
#
# Use MAIN_CMDL and DOCCONF_CMDL in the following in order to avoid that
# these get overwritten by chance with values from the DOCCONF files
# (DOCCONF should never be set in a DC file and MAIN_CMDL should always
# overwrite a MAIN setting from DOCCONF)
# The real values will be set when calling recover_cmdl_values

# set DOCCONF_CMDL if DC-file was parsed
[[ -n "$DOCCONF" && -z "$DOCCONF_CMDL" ]] && DOCCONF_CMDL=$DOCCONF

if [[ -z "$DOCCONF_CMDL" && -z "$MAIN_CMDL" ]]; then
# DOCCONF and MAIN were not set on the command line, check other possibilities
    if [[ -n "$DOCCONF_NAME" ]]; then
    # check if DOCCONF was parsed
    # takes precedence over a default set in config
        if [[ -e "$DOCCONF_NAME" ]]; then
            sanitize_path "$DOCCONF_NAME" "DOCCONF_CMDL"
            DOC_DIR=$(dirname "$DOCCONF_CMDL")
            if [[ 2 -le $VERBOSITY ]]; then
                echo "Using previously parsed DOCCONF $DOCCONF_CMDL"
            fi
        else
            exit_on_error "Cannot find previously parsed DOCCONF \"$DOCCONF_NAME\".\nWhen sourcing the doc config, you either need to run $ME from the directory\nwhere you parsed the config, or you need to provide an absolute path when\nsourcing the doc config."
        fi
    elif [[ -n "$DOCCONF_DEFAULT" ]]; then
    # check if a default value was specified in the user/system config file
        if [[ -e $DOCCONF_DEFAULT ]]; then
            sanitize_path "$DOCCONF_DEFAULT" "DOCCONF_CMDL"
            DOC_DIR=$(dirname "$DOCCONF_CMDL")
            if [[ 2 -le $VERBOSITY ]]; then
                echo "Using DOCCONF $DOCCONF_DEFAULT from config files"
            fi
        else
            exit_on_error "DOCCONF_DEFAULT \"$DOCCONF_DEFAULT\" not found in current directory.\nCheck your config file at $USER_CONFIG."
        fi
    else
    # try to automatically set DOCCONF
        autoset_docconf
    fi
elif [[ -n "$MAIN_CMDL" ]]; then
    # MAIN was set on the command line or in the user config
    set_mainfile "$MAIN_CMDL"
elif [[ -n "$DOCCONF_CMDL" ]]; then
    # check if DOCCONF is a regular file
    if [[ -e $DOCCONF_CMDL ]]; then
        sanitize_path "$DOCCONF_CMDL" "DOCCONF_CMDL"
        DOC_DIR=$(dirname "$DOCCONF_CMDL")
    else
        exit_on_error "The file \"$DOCCONF\" you specified with --docconf is not a valid file"
    fi
fi

#
# Checking MAIN_CMDL, DOCCONF_CMDL, DOC_DIR and DAPSROOT
#

[[ -z "$DOCCONF_CMDL" && -z "$MAIN_CMDL" ]] && exit_on_error "Fatal: Neither \$DOCCONF nor $MAIN are set. This should not have happened"
[[ -z "$DOC_DIR" ]] && exit_on_error "Fatal: \$DOC_DIR is not set. This should not have happened. Please report a bug."
[[ -z "$DAPSROOT" ]] && exit_on_error "Fatal: \$DAPSROOT is not set. This should not have happened. Please report a bug."

# FINALLY! Parse the DOCCONF file, recover the command line values
[[ -n "$DOCCONF_CMDL" ]] && parse_config "$DOCCONF_CMDL"

# FOP/XEP CONFIG and WRAPPER / JING WRAPPER
# when using an SVN checkout, @sysconfdir@ and @pkgdatadir have not been
# replaced
#
# ${string/#substring/replacement}
# If $substring matches front end of $string, substitute
# $replacement for $substring.

FOP_CONFIG_FILE=${FOP_CONFIG_FILE/#@sysconfdir\@\/daps/${DAPSROOT}/etc}
FOP_WRAPPER=${FOP_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

JING_WRAPPER=${JING_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

XEP_CONFIG_FILE=${XEP_CONFIG_FILE/#@sysconfdir\@\/daps/${DAPSROOT}/etc}
XEP_WRAPPER=${XEP_WRAPPER/#@pkgdatadir\@/${DAPSROOT}}

# make all paths absolute, remove trailing / and check
if [[ -n $DOCCONF_CMDL ]]; then
    MY_BASEDIR=$(readlink -en "$(dirname "$DOCCONF_CMDL")")
elif [[ -n $MAIN_CMDL ]]; then
    MY_BASEDIR=$(readlink -en "$(dirname "$MAIN_CMDL")")
else
    exit_on_error "Fatal: Neither a DC nor a MAIN file is set"
fi
recover_cmdl_values
check_pathlist "$MY_BASEDIR"


# If MAIN was not specified on the command line, set MAIN to an absolute
# path
if [[ -z "$MAIN_CMDL" ]]; then
    set_mainfile "$MAIN"
    MAIN="$MAIN_CMDL"
fi


#----------
# Values that need to be exported and are not set in the config
#

# book name
if [[ -n "$PDFNAME" ]]; then
    export BOOK="$PDFNAME"
else
    if [[ -n "$DOCCONF" ]]; then
        DC_FILE=$(basename "$DOCCONF")
        export BOOK="${DC_FILE#${CONF_PREFIX}*}"
    elif [[ -n "$MAIN_CMDL" ]]; then
        # --main was specified, BOOK is set to basenme of MAIN
        BOOK="$(basename "$MAIN" .xml)"
        export BOOK
    fi
fi

# XML_CATALOG_FILES
#
# XML_MAIN_CATALOG is set via config. If it differs from the system setting for
# XML_CATALOG_FILES, add it to XML_CATALOG_FILES (in first place)
#
# Next, check if XML_DEVEL_CATALOG is set. If so, add it to XML_CATALOG_FILES
# (in first place). XML_DEVEL_CATALOG is automatically set by this script when
# working from an SVN checkout
#
if [[ -n "$XML_CATALOG_FILES" ]]; then
    if [[ $XML_CATALOG_FILES != $XML_MAIN_CATALOG ]]; then
        XML_CATALOG_FILES="$XML_CATALOG_FILES $XML_MAIN_CATALOG"
    fi
else
    XML_CATALOG_FILES="$XML_MAIN_CATALOG"
fi
if [[ -n "$XML_USER_CATALOGS" ]]; then
    XML_CATALOG_FILES="$XML_USER_CATALOGS $XML_CATALOG_FILES"
fi
if [[ -n "$XML_DEVEL_CATALOG" ]]; then
    XML_CATALOG_FILES="$XML_DEVEL_CATALOG $XML_CATALOG_FILES"
fi
export XML_CATALOG_FILES

# ----------------------------------------------------------------------------
# Set paths
#
# set all basic paths that have not been set by now

#----------------------------------
# default BUILD_DIR if not specified elsewhere
[[ -z "$BUILD_DIR" ]] && BUILD_DIR=${DOC_DIR}/build

#----------------------------------
# DocBook Stylesheet and Schema locations (from system or user config file)
# These stylesheets are used as a fallback and/or when no STYLEROOT is
# specified on the command line or the DC file
#
# get DocBook version first ...

DOCBOOK_VERSION=$($XSLTPROC --stylesheet "${DAPSROOT}/daps-xslt/common/get-docbook-version.xsl" --file "$MAIN" "$XSLTPROCESSOR") || exit_on_error "Could not get DocBook version. Maybe $MAIN is not well-formed?"

# DocBook 5
#
if [[ 5 = "$DOCBOOK_VERSION" ]]; then
    # resolve stylesheet URN
    #
    if [[ ${DOCBOOK5_STYLE_URI:0:5} = file: ]]; then
        DOCBOOK_STYLES="$DOCBOOK5_STYLE_URI"
    else
        DOCBOOK_STYLES=$(xmlcatalog "$XML_MAIN_CATALOG" \
          "$DOCBOOK5_STYLE_URI" 2>/dev/null) || \
            exit_on_error "Could not determine the DocBook stylesheet location by resolving \"$DOCBOOK5_STYLE_URI\" via xmlcatalog"
    fi
    # also get the RNG scheme location
    #
    if [[ ${DOCBOOK5_RNG_URI:0:5} = file: ]]; then
        DOCBOOK5_RNG="$DOCBOOK5_RNG_URI"
    else
        DOCBOOK5_RNG=$(xmlcatalog "$XML_MAIN_CATALOG" \
          "$DOCBOOK5_RNG_URI" 2>/dev/null) || \
            exit_on_error "Could not determine the DocBook 5 schema location by resolving \"$DOCBOOK5_RNG_URI\" via xmlcatalog"
    fi
    # remove file:// or file: (Debian, Tumbleweed) prefix
    # Is there a better way to do this with shell built-ins?
    #
    DOCBOOK5_RNG=${DOCBOOK5_RNG#*file:}
    DOCBOOK5_RNG=${DOCBOOK5_RNG#*//}
    #
    # check if resulting path is valid
    #
    if [[ ! -s "$DOCBOOK5_RNG" ]]; then
        if [[ -n "$DOCBOOK5_RNG_URI_CMDL" ]]; then
            exit_on_error "The URN specified with --schema points to a non-existing file \"$DOCBOOK5_RNG\""
        else
            exit_on_error "The URN specified with DOCBOOK5_RNG_URI points to a non-existing file \"$DOCBOOK5_RNG\""
        fi
    fi

# DocBook 4
#
elif [[ 4 = "$DOCBOOK_VERSION" ]]; then
    # resolve stylesheet URN
    #
    if [[ ${DOCBOOK4_STYLE_URI:0:5} = file: ]]; then
        DOCBOOK_STYLES="$DOCBOOK4_STYLE_URI"
    else
        DOCBOOK_STYLES=$(xmlcatalog "$XML_MAIN_CATALOG" \
          "$DOCBOOK4_STYLE_URI" 2>/dev/null) || \
            exit_on_error "Could not determine the DocBook stylesheet location by resolving \"$DOCBOOK4_STYLE_URI\" via xmlcatalog"
    fi
else
    exit_on_error "Fatal: Could not determine the DocBook version from $MAIN. Looks like $MAIN is not a DocBook 4/5 document."
fi

# remove the file:// or file: (Debian, Tumbleweed) string from the styles
# use ##*file:// rather than #file:// because sometimes xmlcatalog also outputs
# warnings to stdout which we would like to ignore. Fortunately the file:// url
# is always the last string
#
# Is there a better way to do this with shell built-ins?
#
DOCBOOK_STYLES=${DOCBOOK_STYLES##*file:}
DOCBOOK_STYLES=${DOCBOOK_STYLES#*//}
DOCBOOK_STYLES=${DOCBOOK_STYLES%/}

#
# Check resulting path
#
[[ -d "$DOCBOOK_STYLES" ]] || exit_on_error "DOCBOOK4_STYLE_URI or DOCBOOK5_STYLE_URI points to a non-existing directory \"$DOCBOOK_STYLES\"."

# ...and export
export DOCBOOK_STYLES DOCBOOK5_RNG DOCBOOK_VERSION

#--------------------------
# Get PROFILE_URN to determine whether profiling is turned on
# will get exported via VARLIST
#

 PROFILE_URN=$($XSLTPROC --stylesheet "${DAPSROOT}/daps-xslt/common/get-xml-stylesheet.xsl" --file "$MAIN" "$XSLTPROCESSOR") || exit_on_error "Could not get DocBook version. Maybe $MAIN is not well-formed?"

#----------------------------------
# Result directory / LOG directory
#
R_DIR="${BUILD_DIR}/${BOOK}"
LOG_DIR="${R_DIR}/log"

#-------------------------------------------------------------------
# Now export all variables set by the config file
export "${VARLIST[@]}"

#-------------------------------------------------------------------
# Create a temporary file for SETFILES (setfiles.mk)
# this needs to be done here, otherwise it is impossible to
# delete the file after the script has run
#
SETFILES_TMP=$(mktemp -q --tmpdir daps_setfiles.XXXXXXXX 2>/dev/null) || exit_on_error "Could not write temporary SETFILES file."
export SETFILES_TMP

#-------------------------------------------------------------------
# Finally, run the Subcommands
#

# By default we want to write a logfile, can be overwritten by
# subcommand function
#
WRITE_LOG=1

# Quoting needs to be exactly like this, do not change
#
${SUBCOMMANDS[$SUBCMD]} "$SUBCMD" "${SCMD_ARGS[@]}"

# remove the tmp SETFILE
# done via trap, see above

exit;
